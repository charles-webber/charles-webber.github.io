<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>asuka&amp;ayanami</title>
  
  <subtitle>anobaga?</subtitle>
  <link href="http://charles-webebr.github.io/atom.xml" rel="self"/>
  
  <link href="http://charles-webebr.github.io/"/>
  <updated>2023-10-14T10:26:05.864Z</updated>
  <id>http://charles-webebr.github.io/</id>
  
  <author>
    <name>charles-webber</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python learning</title>
    <link href="http://charles-webebr.github.io/2023/10/09/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    <id>http://charles-webebr.github.io/2023/10/09/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</id>
    <published>2023-10-09T08:35:02.000Z</published>
    <updated>2023-10-14T10:26:05.864Z</updated>
    
    <content type="html"><![CDATA[<p><strong>python学习之路</strong></p><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h2><p>python是一种面向对象**oop(Object Oriented Programming)**的[脚本语言]</p><p>对象包括数据和动作，把数据和方法组成为一个整体，然后对其进行系统的建模</p><p>*核心思想是<strong>理解功能逻辑</strong>！！！</p><h2 id="基本程序设计模式"><a href="#基本程序设计模式" class="headerlink" title="基本程序设计模式"></a>基本程序设计模式</h2><p>任何的程序IPO，它们分别代表如下：</p><ul><li>input输入</li><li>process处理</li><li>output输出</li></ul><p>基本程序设计步骤：</p><ul><li>确定IPO</li><li>编写程序</li><li>调试程序</li></ul><h2 id="解决复杂问题的有效方法"><a href="#解决复杂问题的有效方法" class="headerlink" title="解决复杂问题的有效方法"></a>解决复杂问题的有效方法</h2><h3 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h3><p>其实就是不断将大问题分解成小问题，进行模块化编写</p><p><strong>栗子</strong>：斐波那契数列（递归）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cache = &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">number</span>):</span><br><span class="line">    <span class="keyword">if</span> number <span class="keyword">in</span> cache:</span><br><span class="line">        <span class="keyword">return</span> cache[number]</span><br><span class="line">    <span class="keyword">if</span> number == <span class="number">0</span> <span class="keyword">or</span> number == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cache[number] = fib(number - <span class="number">1</span>) + fib(number - <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> cache[number]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(fib(<span class="number">35</span>))</span><br></pre></td></tr></table></figure><p>cache：在Python中，”cache”这个词通常是指将数据或计算结果存储起来以便以后使用的过程，而不是指计算机硬件中的高速缓冲存储器（Cache）。</p><p>Python中的cache通常用于以下几个方面：</p><ol><li>存储函数或方法的结果，以便以后可以快速地重用这些结果，而不需要重新计算。例如，可以使用<code>functools.lru_cache()</code>装饰器来缓存函数的结果。</li><li>缓存数据库查询的结果，以便在需要时可以快速地获取这些结果，而不需要再次查询数据库。例如，可以使用SQLAlchemy的查询缓存功能。</li><li>缓存网页或API响应的结果，以便在需要时可以快速地获取这些结果，而不需要再次发出请求。例如，可以使用requests库的响应缓存功能。</li></ol><p>这些cache的实现通常是使用Python中的字典或其他数据结构来存储和检索数据。它们与计算机硬件中的高速缓冲存储器（Cache）不同，但是它们都使用了类似的概念，即<strong>将数据或计算结果存储起来以便以后使用，以提高性能和效率。</strong></p><p>（有点数组的味道，cache[number]中number相当于一个门牌，在这个里面存放了计算后的数据）</p><h3 id="自底向上-模块化集成"><a href="#自底向上-模块化集成" class="headerlink" title="自底向上-模块化集成"></a>自底向上-模块化集成</h3><p>栗子：0-1背包问题</p><p>问题:你现在想买⼀大堆算法书，有一个容量为 <strong>V</strong> 的背包，这个商店⼀共有 <strong>n</strong> 个商品。问题在于，你最多只能拿 <strong>W</strong> kg 的东西，其中 <strong>wi</strong> 和 <strong>vi</strong> 分别表示第 <strong>i</strong> 个商品的重量和价值。最终的目标就是在能拿的下的情况下，获得最大价值，求解哪些物品可以放进背包。</p><p>作为一个聪明的贼，你用 表示偷到商品的总价值，其中i表示一共多少个商品，w表示总重量，所以求解就是我们的子问题，那么你看到某一个商品i的时候，如何决定是不是要装进背包，有以下几点考虑：</p><ol><li>该物品的重量大于背包的总重量，不考虑，换下一个商品；</li><li>该商品的重量小于背包的总重量，那么我们尝试把它装进去，如果装不下就把其他东西换出来，看看装进去后的总价值是不是更高了，否则还是按照之前的装法；</li><li>极端情况，所有的物品都装不下或者背包的承重能力为0，那么总价值都是0；</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 循环的⽅式，自底向上求解</span></span><br><span class="line">cache = &#123;&#125;</span><br><span class="line">items = <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">9</span>)</span><br><span class="line">weights = [<span class="number">10</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">5</span>]</span><br><span class="line">values = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">15</span>,<span class="number">40</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">18</span>]</span><br><span class="line"><span class="comment"># 最⼤承重能⼒</span></span><br><span class="line">W = <span class="number">4</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">knapsack</span>():</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(W+<span class="number">1</span>):</span><br><span class="line">        cache[get_key(<span class="number">0</span>,w)] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> items:</span><br><span class="line">        cache[get_key(i,<span class="number">0</span>)] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(W+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> w &gt;= weights[i]:</span><br><span class="line">                <span class="keyword">if</span> cache[get_key(i-<span class="number">1</span>,w-weights[i])] + values[i] &gt; cache[get_key(i-<span class="number">1</span>,w)]:</span><br><span class="line">                    cache[get_key(i,w)] = values[i] + cache[get_key(i-<span class="number">1</span>,w-weights[i])]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cache[get_key(i,w)] = cache[get_key(i-<span class="number">1</span>,w)]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cache[get_key(i,w)] = cache[get_key(i-<span class="number">1</span>,w)]</span><br><span class="line">    <span class="keyword">return</span> cache[get_key(<span class="number">8</span>,W)]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_key</span>(<span class="params">i,w</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(i)+<span class="string">&#x27;,&#x27;</span>+<span class="built_in">str</span>(w)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 背包把所有东西都能装进去做假设开始</span></span><br><span class="line">    <span class="built_in">print</span>(knapsack())</span><br><span class="line">    <span class="number">29</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;看不懂啊现在，史密达</p><h2 id="标准库模块导入"><a href="#标准库模块导入" class="headerlink" title="标准库模块导入"></a>标准库模块导入</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">python_modules = [</span><br><span class="line">  <span class="string">&quot;os --- 多种操作系统接口&quot;</span>,</span><br><span class="line">  <span class="string">&quot;os.path --- 常用路径操作&quot;</span>,</span><br><span class="line">  <span class="string">&quot;re --- 正则表达式操作&quot;</span>,</span><br><span class="line">  <span class="string">&quot;datetime --- 基本日期和时间类型&quot;</span>,</span><br><span class="line">  <span class="string">&quot;heapq --- 堆队列算法&quot;</span>,</span><br><span class="line">  <span class="string">&quot;enum --- 对枚举的支持&quot;</span>,</span><br><span class="line">  <span class="string">&quot;math --- 数学函数&quot;</span>,</span><br><span class="line">  <span class="string">&quot;random --- 生成伪随机数&quot;</span>,</span><br><span class="line">  <span class="string">&quot;itertools --- 为高效循环而创建迭代器的函数&quot;</span>,</span><br><span class="line">  <span class="string">&quot;functools --- 高阶函数和可调用对象上的操作&quot;</span>,</span><br><span class="line">  <span class="string">&quot;shutil --- 高阶文件操作&quot;</span>,</span><br><span class="line">  <span class="string">&quot;sqlite3 --- SQLite 数据库 DB-API 2.0 接口模块&quot;</span>,</span><br><span class="line">  <span class="string">&quot;csv --- CSV 文件读写&quot;</span>,</span><br><span class="line">  <span class="string">&quot;hashlib --- 安全哈希与消息摘要&quot;</span>,</span><br><span class="line">  <span class="string">&quot;hmac --- 基于密钥的消息验证&quot;</span>,</span><br><span class="line">  <span class="string">&quot;time --- 时间的访问和转换&quot;</span>,</span><br><span class="line">  <span class="string">&quot;argparse --- 命令行选项、参数和子命令解析器&quot;</span>,</span><br><span class="line">  <span class="string">&quot;logging --- Python 的日志记录工具&quot;</span>,</span><br><span class="line">  <span class="string">&quot;threading --- 基于线程的并行&quot;</span>,</span><br><span class="line">  <span class="string">&quot;multiprocessing --- 基于进程的并行&quot;</span>,</span><br><span class="line">  <span class="string">&quot;socket --- 底层网络接口&quot;</span>,</span><br><span class="line">  <span class="string">&quot;email --- 电子邮件与 MIME 处理包&quot;</span>,</span><br><span class="line">  <span class="string">&quot;json --- JSON 编码和解码器&quot;</span>,</span><br><span class="line">  <span class="string">&quot;urllib --- URL 处理模块&quot;</span>,</span><br><span class="line">  <span class="string">&quot;http --- HTTP 模块&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="缩进规则"><a href="#缩进规则" class="headerlink" title="缩进规则"></a>缩进规则</h2><p>缩进来表示块作用域的开始和结束（其他语言一般使用{}）</p><p>Python 对缩进有严格的要求，同一个源文件里，缩进必须保持一致，<strong>例如都是2个空格或者4个空格</strong>。Python 这么做的理由是使用缩进更简洁，同时不用考虑<code>&quot;&#123;&quot;</code>要放在哪一行，而且是用缩进足够Python解释器正确解析。但是使用缩进如果没有编辑器自动检测和格式化也会带来一些不必要的麻烦。</p><h3 id="正确案例"><a href="#正确案例" class="headerlink" title="正确案例"></a>正确案例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">**<span class="comment"># 这是一个 Python 程序** </span></span><br><span class="line"><span class="keyword">if</span> i&lt;<span class="number">10</span>:    </span><br><span class="line">    <span class="keyword">if</span> i&lt;<span class="number">5</span>:    //<span class="number">2</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;win more!&quot;</span>) //<span class="number">4</span>   </span><br><span class="line"><span class="keyword">else</span>:       //<span class="number">2</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;win&quot;</span>)//<span class="number">4</span> </span><br><span class="line"><span class="keyword">else</span>:   </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;loose&quot;</span>)//<span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="错误案例"><a href="#错误案例" class="headerlink" title="错误案例"></a>错误案例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">    c = <span class="number">5</span></span><br><span class="line">    <span class="built_in">max</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">max</span>:</span><br><span class="line">        d = <span class="built_in">max</span>-i-i//（应该全都是<span class="number">4</span>或者<span class="number">2</span>）</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">abs</span>(d) &lt; <span class="number">3</span>:（<span class="number">6</span>格）再往右边走两格</span><br><span class="line">        <span class="built_in">print</span>(i, <span class="built_in">max</span>-i)</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>def 函数名(参数列表)：    </p><p>函数体</p><p>例如</p><p>def hello():    </p><p>print(“hello”)</p><p>print(“world!”)</p><p>————————</p><p>以下代码定义了无任何操作的空函数nop()。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nop</span>():</span><br><span class="line">    <span class="keyword">pass</span>//c中就有nop函数</span><br></pre></td></tr></table></figure><p>在Python代码中，pass语句通常可以用来作为占位符，表示什么操作都不执行。比如在项目起始阶段，如果还没想好函数具体实现时，可以先放置一个pass语句，让代码先成功运行起来。待项目框架搭建完毕后，在进行相应的具体实现。</p><h3 id="函数定义规则"><a href="#函数定义规则" class="headerlink" title="函数定义规则"></a>函数定义规则</h3><ul><li>函数代码块以def关键字开头，后接函数标识符名称和形参列表；</li><li>任何传入的参数和自变量必须放在圆括号内；</li><li>函数的第一行语句可以选择性地使用文档字符串（即函数说明）；？？</li><li>函数内容以冒号起始，并且严格统一缩进；</li><li>函数都有返回值，默认返回None。</li></ul><h3 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h3><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/370218a1ee13497aa9e14a75430aadc1.png" alt="在这里插入图片描述"></p><p>除此之外的就是第三方函数，在Python语言中，还可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”，如下代码所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">abs</span></span><br><span class="line"><span class="built_in">print</span>(a(-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><p>当内建函数不能满足要求时，开发者可以根据实际需要自定义函数。函数自定义完成后，开发者可以在其他代码处通过函数名调用。如下代码演示了自定义函数printme()的定义和调用过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printme</span>(<span class="params"><span class="built_in">str</span></span>):</span><br><span class="line">    <span class="string">&quot;函数功能：打印传入的字符串&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用自定义函数</span></span><br><span class="line">printme(<span class="string">&quot;调用用户自定义函数！&quot;</span>)</span><br><span class="line">printme(<span class="string">&quot;再次调用用户自定义函数！&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调用用户自定义函数！</span><br><span class="line">再次调用用户自定义函数！</span><br></pre></td></tr></table></figure><p>上述代码中，自定义了一个函数printme()，并对其进行两次调用，测试相应功能。在实际开发中，涉及到大量的自定义函数。在自定义函数中，也可以调用内建函数或其他自定义函数。自定义函数和内建函数的定义方式是相同，只不过是自定义函数是有开发者定义的，而内建函数是由系统定义的。两者的调用方式都是一样的。</p><p>在Python语言中，内建函数可以直接使用，第三方函数需要使用import命令导入相应的库才能使用。对于自定义函数，其定义和调用可以在同一个文件中，也可分离成不同的文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> hello</span><br><span class="line"></span><br><span class="line">hello()</span><br></pre></td></tr></table></figure><p>上述代码演示了函数的定义和调用不在一个文件的情形。首先，将hello()函数定义好并保存为test.py文件，然后使用Python语言的import指令“from test import hello”将该文件导入，可以调用hello()函数了。导入时需要注意test是文件名并且不含.py扩展名。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul><li><p>类 ：是对实体的抽象，是泛指，比如：动物、植物等。</p></li><li><p>对象：是类的一个实例，是特例，比如：猫、狗等。</p></li></ul><p>例如：动物可以对猫的特征和行为进行抽象，然后可以实例化为真实的动物实体。</p><p>在采用面向对象思想编程时，可依次采用以下步骤：</p><p>（1）分析哪些动作是由哪些实体发出的；<br>（2）定义这些实体，为其增加相应的属性和功能；<br>（3）让实体去执行相应的功能或动作。</p><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>Python语言中，使用class关键字来创建类，其创建方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>(<span class="title class_ inherited__">bases</span>):</span><br><span class="line">    <span class="comment"># class documentation string 类文档字符串，对类进行解释说明</span></span><br><span class="line">    class_suite</span><br></pre></td></tr></table></figure><p>class是<code>关键字</code>，bases是要继承的<code>父类</code>，默认继承<code>object</code>类。<br>class documentation string是类<code>文档字符串</code>，一般用于<code>类的注释说明</code>。class_suite是<code>类体</code>，主要包含<code>属性</code>和<code>方法</code>。</p><p>类、属性和方法的命名约定惯例如下：</p><ul><li><code>类名</code>表示实例的抽象，命名时<code>首字母大写</code>；</li><li><code>属性</code>使用名词作为名字，比如name、age、weight等；</li><li><code>方法</code>名一般指对属性的操作，其命名规则一般采用动词加属性名称形式，如updataName、updataAge、updataWeight等。 举例如下图：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:  <span class="comment"># 类名</span></span><br><span class="line">    name = <span class="string">&quot;张三&quot;</span>  <span class="comment"># 属性名</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">undate_name</span>(<span class="params">self, name</span>):<span class="comment"># 方法名</span></span><br><span class="line">        self.name = name  </span><br></pre></td></tr></table></figure><p><strong>在Python3.x中，如果没有显示指明要继承的父类，则默认继承<code>object</code>类。</strong></p><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>类创建完之后，就应该创建该类的实例或对象了，该过程称之为实例化。当一个对象被创建后，就包含<strong>标识</strong>、<strong>属性</strong>和<strong>方法</strong>这三个方面的对象特性了。其中，对象标识用于区分不同的对象，属性和方法与类中的成员变量和成员函数相对应</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people = People(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>, <span class="string">&quot;50kg&quot;</span>)  <span class="comment"># 实例化一个对象</span></span><br></pre></td></tr></table></figure><p>如例子所示，对象标识符为people，属性为括号中内容，方法为类中方法</p><h3 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h3><ol><li><p>Python语言中，属性分为类级别和实例级别两种。实例级别的属性值默认共享类级别的属性值。除非显式进行赋值操作</p></li><li><p>属性操作的三个原则：</p><p>（1）属性的获取是按照从下到上的顺序来查找属性；<br>（2）类和实例是两个完全独立的对象；<br>（3）属性设置是针对实例本身进行的。</p></li><li><p>属性和方法的分类：</p></li></ol><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20231011002732011.png" alt="image-20231011002732011"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20231011002753974.png" alt="image-20231011002753974"></p><p>栗子：<img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/39f273d5f46e4c0e92d7a0f76fabb9e6.png" alt="在这里插入图片描述"></p><h3 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h3><p>在Python语言中，所有以双下划线“<strong>”包起来的方法，都统称为“魔术方法”。 这些方法在实例化时会自动调用， 比如“_str</strong>()”、“<strong>init</strong>()”、“<strong>del</strong>()”等。 使用魔术方法可以构造出非常优美的代码，比如将复杂的逻辑封装成简单的API等。</p><p>栗子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>():</span><br><span class="line">    name = <span class="string">&quot;人&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n=<span class="string">&quot;非洲人&quot;</span></span>):</span><br><span class="line">        self.name = n</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我是构造函数&quot;</span>, self.name)  <span class="comment"># 重写构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我是析构函数&quot;</span>, self.name)  <span class="comment"># 重写析构函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">zhangsan = People()</span><br><span class="line">lisi = People(<span class="string">&quot;欧美人&quot;</span>)</span><br><span class="line">zhangsan.__del__()  <span class="comment"># 调用析构函数</span></span><br><span class="line"><span class="built_in">print</span>(zhangsan)</span><br><span class="line"><span class="keyword">del</span> zhangsan</span><br><span class="line"><span class="built_in">print</span>(zhangsan) <span class="comment">#出现错误，因为del后，对象就不存在了</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我是构造函数 非洲人    张三</span><br><span class="line">我是构造函数 欧美人    李四</span><br><span class="line">我是析构函数 非洲人    调用del后print</span><br><span class="line">&lt;__main__.People object at 0x000001EAF4D09358&gt;</span><br></pre></td></tr></table></figure><h3 id="类间关系"><a href="#类间关系" class="headerlink" title="类间关系"></a>类间关系</h3><ol><li>依赖关系</li><li>关联关系</li><li>继承关系！！！</li></ol><h2 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>算术运算符：+、-、<em>、&#x2F;、&#x2F;&#x2F;、%、</em>*<br>关系运算符：<img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/aae4d68d5b2043f6967990c610567bcd.png" alt="在这里插入图片描述"></p><p>Python支持通过保留字not、and和or对判断条件进行逻辑组合：</p><ul><li>not，表示单个条件的“否”关系。如果“条件”的布尔属性为True，“not 条件”的布尔属性就为False；如果“条件”的布尔属性为False，“not 条件”的布尔属性就为True。</li><li>and，表示多个条件之间的“与”关系。当且仅当使用and连接的所有条件的布尔属性都为True时，逻辑表达式的布尔属性为True，否则为False。</li><li>or，表示多个条件之间的“或”关系。当且仅当使用or连接的所有条件的布尔属性都是False时，逻辑表达式的布尔属性为False，否则为True。</li></ul><h3 id="三元表达式"><a href="#三元表达式" class="headerlink" title="三元表达式"></a>三元表达式</h3><p>格式：条件判断为真时的结果| if 判断条件| else 条件为假时的结果<br>示例：<strong>x&#x3D;x-1 if x&gt;0 else x&#x3D;x+1</strong><br>等价于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">    x = x - <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    x = x + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>栗子</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> n <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> fun(n - <span class="number">1</span>) + fun(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>python中的for循环与c语言的有点不一样</p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/d898c790ad4543a8922375100c76af9e.png" alt="在这里插入图片描述"></p><ul><li>目标可以是字符串、文件、range()函数或组合数据类型等；</li><li>循环变量用于保存本次循环中访问到的遍历结构中的元素；</li><li>for循环的循环次数取决于遍历的目标元素个数。</li></ul><p>示例1：遍历字符串中的每个字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string = <span class="built_in">input</span>(<span class="string">&quot;请输入一个字符串：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> string:</span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure><h3 id="PASS"><a href="#PASS" class="headerlink" title="PASS"></a>PASS</h3><p>pass的意思是过，pass掉就是淘汰掉的意思。</p><p>在python中，pass的意思是空语句，pass语句不做任何事情，只是为了保持程序结构的完整性。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h2><h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><ol><li>整型（int）</li><li>浮点型（float）</li><li>复数类型（complex）</li><li>布尔类型（bool）</li></ol><h3 id="复数"><a href="#复数" class="headerlink" title="*复数"></a>*复数</h3><ul><li>复数由“实部”和“虚部”两部分组成；</li><li>实数部分和虚数部分都是浮点型；</li><li>虚数部分后面必须有j或J</li></ul><p>Python中表示复数的两种方法：</p><ol><li>a+bj</li><li>complex(a,b)<br>其中a表示实部，b表示虚部<br>举例：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span> + <span class="number">6</span>j</span><br><span class="line">print(type(a))</span><br><span class="line">b = <span class="type">complex</span>(<span class="number">2</span>, <span class="number">6</span>)</span><br><span class="line">print(type(b))</span><br><span class="line">print(id(a), id(b))</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">complex</span>&#x27;&gt;</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">complex</span>&#x27;&gt;</span></span><br><span class="line"><span class="number">2718471372752</span> <span class="number">2718437554352</span></span><br></pre></td></tr></table></figure><p>获取复数的实部、虚部、共轭复数等</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span> + <span class="number">6j</span></span><br><span class="line"><span class="built_in">print</span>(a.imag)  <span class="comment"># .imag可以获取复数的虚部</span></span><br><span class="line"><span class="built_in">print</span>(a.real)  <span class="comment"># .real可以获取复数的虚部</span></span><br><span class="line"><span class="built_in">print</span>(a.conjugate())  <span class="comment"># .conjugate()方法可以获取复数的共轭复数</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6.0</span></span><br><span class="line"><span class="number">2.0</span></span><br><span class="line">(<span class="number">2</span>-<span class="number">6j</span>)</span><br></pre></td></tr></table></figure><h3 id="数值计算函数库"><a href="#数值计算函数库" class="headerlink" title="数值计算函数库"></a>数值计算函数库</h3><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/734cddbe0f274ccb93a2107c953c7a02.png" alt="在这里插入图片描述"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/bdf2e0ce75b64a40855c57bdc819bab0.png" alt="在这里插入图片描述"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/713f45f3adc34300b1a07f9ef37c6876.png" alt="在这里插入图片描述"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/5c4dbdbf93f742cd9ac96630ccd415ed.png" alt="在这里插入图片描述"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/882eaa80b3ee4da5aef10a8d0846dfe5.png" alt="在这里插入图片描述"></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(random.random())  <span class="comment"># random.random()作用是生成一个[0-1]范围内的随机数</span></span><br><span class="line"><span class="built_in">print</span>(random.randint(<span class="number">1</span>, <span class="number">2000</span>))  <span class="comment"># random.randint(a,b)作用是生成一个[a-b]范围内的随机整数</span></span><br></pre></td></tr></table></figure><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><h4 id="三重引号"><a href="#三重引号" class="headerlink" title="三重引号"></a>三重引号</h4><p>三重引号可以是<code>三个单引号</code>，也可以是<code>三个双引号</code>。这种方式表示的字符串也叫做<code>块字符串</code>。</p><p>三重引号是以三个同一种类型的引号开始，并以三个相同引号结束的字符串表示方式。</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/b0f542a8c6e7463897bb5acee8a59338.png" alt="在这里插入图片描述"></p><p>&#x2F;&#x2F;和C语言的&#x2F;*  *&#x2F;语句类似（字符串中出现了“\n”换行符，这是因为敲了回车）</p><h3 id="raw字符串"><a href="#raw字符串" class="headerlink" title="raw字符串"></a>raw字符串</h3><p>raw字符串的格式是r’…’。</p><p>在raw字符串中，所有的字符都是直接按照字面意思来解释，没有转义字符或者不能打印的字符。</p><p>栗子：<img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/33c3a99bebb247819089f1069fe7e197.png" alt="在这里插入图片描述"></p><ul><li>第一种方式的语句打开一个文件时，字符“\n”会被当作回车键的转义字符，从而使文件打开失败。</li><li>第二种方式对反斜杠“\”进行转义，虽然正确，但是代码看起来会令人感到费解。</li><li>第三种就是pthon语言中的raw字符串。</li></ul><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/c8c95c08bb9a4bab98c2e38873efb1bb.png" alt="在这里插入图片描述"></p><p>有反向索引，很方便</p><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>使用Python语言的分片(slice)操作，来提取字符串中的子序列。</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/fb9c92d1b0f142588e28d1dccc3f4a51.png" alt="img"></p><p>s[start:end :dir]—start是提取的开头，而end是提取的末尾，dir既有控制方向和倍数的功能，例如s[1：6：2]表示从序号1开始到六按1+2n取元素直到6，为1 3 5 </p><h4 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h4><ol><li>操作符+的方法</li></ol><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/1fe6df7b08d14add97ac5ac3ec9e83f3.png" alt="在这里插入图片描述"></p><ol><li>Python语言使用符串格式化操作符(%)和join()方法这两种方式连接字符串。</li></ol><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/8faa079855af4b458bddf66c8b6a68f6.png" alt="在这里插入图片描述"></p><ol start="3"><li><strong>join()方法：</strong></li></ol><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/92829cdcfbe047e2bf58e9b81959f683.png" alt="在这里插入图片描述"></p><h4 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h4><ol><li>加号完再切片</li><li>replace函数修改</li></ol><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/e945efb469c74bada39988e4be267501.png" alt="在这里插入图片描述"></p><h4 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/6a610c9cdf454bb791df9bbe05fab390.png" alt="在这里插入图片描述"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/530dee4d8baf40cab717bbb27e39cd5d.png" alt="在这里插入图片描述"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/1ba28d988e9544ad96e80d2bc428c5bc.png" alt="在这里插入图片描述"></p><p>栗子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%c,%c&quot;</span> % (<span class="number">65</span>, <span class="number">97</span>))</span><br><span class="line">s = <span class="string">&#x27;podjsd&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%s&quot;</span> % (s))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%r&#x27;</span>%<span class="number">42</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%e&#x27;</span>%<span class="number">200.21</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%g&#x27;</span>%<span class="number">200.21</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%%&#x27;</span>%())</span><br></pre></td></tr></table></figure><h4 id="函数格式化"><a href="#函数格式化" class="headerlink" title="函数格式化"></a>函数格式化</h4><p>就是利用format（）方法对字符串进行格式化操作，format（）方法使用方法：</p><ul><li><p>不带编号，即“{}”；</p></li><li><p>带数字编号，可调换顺序，如“{0}”、“{1}”等；</p></li><li><p>带关键字，如“{name}”、“{age}”等。<br>例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a=&#123;&#125;,b=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">2</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a=&#123;0&#125;,b=&#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">2</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a=&#123;1&#125;,b=&#123;0&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">2</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a=&#123;num2&#125;,b=&#123;num3&#125;&quot;</span>.<span class="built_in">format</span>(num2=<span class="number">2</span>, num3=<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a=&#123;num3&#125;,b=&#123;num2&#125;&quot;</span>.<span class="built_in">format</span>(num2=<span class="number">2</span>, num3=<span class="number">4</span>))</span><br></pre></td></tr></table></figure></li></ul><h4 id="数字格式化"><a href="#数字格式化" class="headerlink" title="数字格式化"></a>数字格式化</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/defd8e16400e4bc99ee33c1bf21265a4.png" alt="在这里插入图片描述"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/1c228521780949e1b45b2ce7d72bf0b6.png" alt="在这里插入图片描述"></p><h4 id="字典格式化"><a href="#字典格式化" class="headerlink" title="字典格式化"></a>字典格式化</h4><p>在Python语言中，字典格式化是在左边的格式化字符串通过引用右边字典中的<strong>键</strong>来提取对应的值，实现格式化输出。</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/2cc82bb7d4e5457690995f47ff3c2f09.png" alt="在这里插入图片描述"></p><p>（“ ”中的就叫key，注意括号外的s别忘了：“%(name)s,%(age)s”）</p><h3 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h3><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><p>创建列表：<br><code>变量名 = [元素1,元素2,…,元素n]</code></p><p>list类型中区分元素的顺序，且允许包含重复的元素。</p><h5 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h5><p>分正向和反向索引</p><h5 id="切片-1"><a href="#切片-1" class="headerlink" title="切片"></a>切片</h5><p>切片操作可以截取列表变量中的部分元素，并返回一个子列表变量。</p><h5 id="加法和乘法"><a href="#加法和乘法" class="headerlink" title="加法和乘法"></a>加法和乘法</h5><ul><li>加法操作使用加号（+）完成，表示把加号两端的列表变量连接形成一个新列表；</li><li>乘法操作使用星号（*）完成，表示对当前列表对象进行复制并连接，并形成一个新列表。</li></ul><h5 id="修改和删除"><a href="#修改和删除" class="headerlink" title="修改和删除"></a>修改和删除</h5><ul><li>通过索引值对相应元素进行修改或删除。</li><li>删除整个列表或列表中的部分元素，使用<strong>del命令</strong>。删除整个列表后，不可再次引用。</li></ul><h5 id="追加插入和扩展"><a href="#追加插入和扩展" class="headerlink" title="追加插入和扩展"></a>追加插入和扩展</h5><ul><li>append：在当前列表对象尾部追加元素；</li><li>insert：在当前列表的指定索引位置插入元素；</li><li>extend：对当前列表元素进行批量增加</li></ul><h4 id="多维列表"><a href="#多维列表" class="headerlink" title="多维列表"></a>多维列表</h4><p>栗子：</p><p>创建三个列表类型的变量a、n和x。其中，变量a和n中元素都是基本类型，变量x中的元素都是列表类型。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = [<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [a,n]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[[<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>],[<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">0</span>] <span class="comment"># 显示第一个元素 </span></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">0</span>][<span class="number">1</span>] <span class="comment"># 显示第一个元素中的第二个元素 </span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>不清楚：首先创建了一个列表类型变量lst，然后创建了该列表的迭代器对象lstiter，并且通过该迭代器对象的__next__()方法遍历列表中的元素。<br><code>__next__()</code>方法，返回下一个值。iter方法访问列表。</p><h4 id="列表解析"><a href="#列表解析" class="headerlink" title="列表解析"></a>列表解析</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>] <span class="comment">#方法1：直接指定</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">list</span>=[]<span class="comment">#方法2：先创建一个空列表，然后通过for循环实现</span></span><br><span class="line">   <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">      <span class="built_in">list</span>.append(n);</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>)) <span class="comment">#方法3：列表解析</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)] </span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br><span class="line"><span class="comment"># 或者字母所进行的两层循环</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">&#x27;ABC&#x27;</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">&#x27;XYZ&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;AX&#x27;</span>, <span class="string">&#x27;AY&#x27;</span>, <span class="string">&#x27;AZ&#x27;</span>, <span class="string">&#x27;BX&#x27;</span>, <span class="string">&#x27;BY&#x27;</span>, <span class="string">&#x27;BZ&#x27;</span>, <span class="string">&#x27;CX&#x27;</span>, <span class="string">&#x27;CY&#x27;</span>, <span class="string">&#x27;CZ&#x27;</span>]</span><br></pre></td></tr></table></figure><h4 id="列表函数和方法"><a href="#列表函数和方法" class="headerlink" title="列表函数和方法"></a>列表函数和方法</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/f349e6e2cfc44ea587fabb13e28078be.png" alt="在这里插入图片描述"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/d5823afa886d49d0af66d9a80e4ce94f.png" alt="在这里插入图片描述"></p><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><h5 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h5><p>创建元组：<br><code>变量名 = (元素1,元素2,…,元素n)</code></p><p><code>注意：</code><br>当元组中只包含<code>一个</code>元素时，需要在元素后面添加<code>逗号</code>，否则括号会被当作运算符使用。</p><h5 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h5><p>使用索引进行访问</p><h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><p>元组中的元素值是不允许修改的，可以对元组进行连接生成新的元组。</p><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>元素值不允许删除的，但可使用del语句删除整个元组。<br>需要注意的是，删除后的元组对象不可再次引用。</p><h5 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h5><p>通过内置的count方法统计某个元素出现的次数。</p><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><p>通过内置的index方法查找某个元素首次出现的索引位置。</p><h5 id="元组函数和方法"><a href="#元组函数和方法" class="headerlink" title="元组函数和方法"></a>元组函数和方法</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/93992a05fd3d43cba9b7f750a71434cc.png" alt="在这里插入图片描述"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/e4d17925e636470ba7c6fdc92bf2a94a.png" alt="在这里插入图片描述"></p><p>表中的count方法和index方法，实际是元组类型和列表类型所共有的方法，其使用方法和列表完全相同。</p><h5 id="元组优势"><a href="#元组优势" class="headerlink" title="元组优势"></a>元组优势</h5><ul><li>可以使函数返回多个值</li><li>可以使程序运行性能提升</li><li>一般来说，创建元组类型tuple的变量比列表类型list要快，而且占用更小的存储空间。</li><li>使用元组是线程安全的</li><li>元组类型变量的元素不可更改性，可保证多线程读写时的安全问题。</li></ul><h3 id="dict（字典）"><a href="#dict（字典）" class="headerlink" title="dict（字典）"></a>dict（字典）</h3><h4 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h4><p>创建字典对象：<br><code>变量名=(key1:value1, key2:value2,…, keyn:valuen)</code></p><ul><li>字典的元素是可变的，可以是列表、元组、字典等任意数据类型，但键(key)值必须使用不可变类型。</li><li>在同一个字典变量中，键(key) 值必须是唯一的。</li></ul><p>和元组区别就是有个key</p><h4 id="访问-1"><a href="#访问-1" class="headerlink" title="访问"></a>访问</h4><p>字典是无序的，没有索引，不能通过下标索引。通过对key值的索引进行访问。</p><h4 id="修改-1"><a href="#修改-1" class="headerlink" title="修改"></a>修改</h4><p>通过对key值的引用对value值的修改操作。</p><h4 id="字典的嵌套"><a href="#字典的嵌套" class="headerlink" title="字典的嵌套"></a>字典的嵌套</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;Va1 = &#123;a:&#123;b:<span class="number">1</span>,c:<span class="number">2</span>&#125;,d:&#123;e:<span class="number">3</span>,f:<span class="number">4</span>&#125;&#125; <span class="comment">#字典的value值是字典</span></span><br><span class="line">&gt;&gt;&gt;Va2 = &#123;a:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],b:[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]&#125;  <span class="comment">#字典的value值是序列</span></span><br><span class="line">&gt;&gt;&gt;n1=&#123;<span class="string">&#x27;surname&#x27;</span>:<span class="string">&#x27;wang&#x27;</span>,<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;gang&#x27;</span>&#125;  </span><br><span class="line">&gt;&gt;&gt;n2=&#123;<span class="string">&#x27;surname&#x27;</span>:<span class="string">&#x27;zhang&#x27;</span>,<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;san&#x27;</span>&#125;  </span><br><span class="line">&gt;&gt;&gt;n3=&#123;<span class="string">&#x27;surname&#x27;</span>:<span class="string">&#x27;liu&#x27;</span>,<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;wen&#x27;</span>&#125;  </span><br><span class="line">&gt;&gt;&gt;n4=[n1,n2,n3]  <span class="comment">#序列的元素是字典</span></span><br></pre></td></tr></table></figure><p>n1、n2、n3是字典类型的变量，n4是列表类型变量，且n4中的元素即为n1、n2、n3。</p><h4 id="字典的遍历"><a href="#字典的遍历" class="headerlink" title="字典的遍历"></a>字典的遍历</h4><p>栗子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">username=&#123;<span class="string">&#x27;full_name&#x27;</span>:<span class="string">&#x27;ZhangWei&#x27;</span>, <span class="string">&#x27;surname&#x27;</span>:<span class="string">&#x27;Zhang&#x27;</span>, <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;Wei&#x27;</span>  &#125;  </span><br><span class="line"><span class="comment">#遍历所有的键-值对  </span></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> username.items():</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&#x27;key:&#x27;</span>+k)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;value:&#x27;</span>+v+<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#遍历所有键  </span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> username.keys():</span><br><span class="line"><span class="built_in">print</span>(k)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;key:&#x27;</span>+k+<span class="string">&#x27;-value:&#x27;</span>+username[k])</span><br><span class="line"><span class="comment">#遍历所有的值</span></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> username.values():</span><br><span class="line"><span class="built_in">print</span>(v)</span><br></pre></td></tr></table></figure><h4 id="字典函数和方法"><a href="#字典函数和方法" class="headerlink" title="字典函数和方法"></a>字典函数和方法</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/5ae2cc7d2062475a80dd386754bb3d81.png" alt="在这里插入图片描述"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/5eb36fefaf59424eb5e5b9468d9c058d.png" alt="在这里插入图片描述"></p><h3 id="集合（set）"><a href="#集合（set）" class="headerlink" title="集合（set）"></a>集合（set）</h3><h4 id="创建-3"><a href="#创建-3" class="headerlink" title="创建"></a>创建</h4><p>创建集合对象：<br><code>变量名 = &#123;元素1,元素2,…,元素n&#125;</code></p><h4 id="集合特性"><a href="#集合特性" class="headerlink" title="集合特性"></a>集合特性</h4><ul><li>无序性：元素之间没有确定的顺序。</li><li>互异性：不会出现重复的元素。</li><li>确定性：元素和集合只有属于或不属于的关系。</li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>创建空集合用set()；<br>{}创建一个空字典。</p><h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/48bf515f6b254898b4d8b9cc41f70d6e.png" alt="在这里插入图片描述"></p><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p><strong>1. 更改</strong></p><ul><li>add（）：添加一个元素</li><li>update（）：同时添加多个元素</li></ul><p><strong>2. 删除</strong></p><ul><li>discard() 和 remove() 方法删除集合中特定的元素</li><li>若删除的对象不存在，remove（）方法会引起错误，discard（）方法不会</li></ul><h4 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/22017e3d66df4266a9f69bbb4cd76ce8.png" alt="在这里插入图片描述"></p><h4 id="集合函数和方法"><a href="#集合函数和方法" class="headerlink" title="集合函数和方法"></a>集合函数和方法</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/22632c5163594f5b833634e93fca8053.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">python learning for AI</summary>
    
    
    
    
    <category term="note" scheme="http://charles-webebr.github.io/tags/note/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://charles-webebr.github.io/2023/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"/>
    <id>http://charles-webebr.github.io/2023/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/</id>
    <published>2023-09-26T05:55:30.603Z</published>
    <updated>2023-10-14T10:08:21.079Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一节：概述"><a href="#第一节：概述" class="headerlink" title="第一节：概述"></a><strong>第一节：概述</strong></h1><h2 id="1-1-计算机网络在信息时代的作用"><a href="#1-1-计算机网络在信息时代的作用" class="headerlink" title="1.1 计算机网络在信息时代的作用"></a>1.1 计算机网络在信息时代的作用</h2><h3 id="1-1-1-定义"><a href="#1-1-1-定义" class="headerlink" title="1.1.1 定义"></a>1.1.1 定义</h3><p>Internet是全球最大的，最重要的计算机网络，是计算机网络的一部分</p><h3 id="1-1-2特点"><a href="#1-1-2特点" class="headerlink" title="1.1.2特点"></a>1.1.2特点</h3><p>1.连通性（connectivity）2.资源共享（sharing）</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230716125923545.png" alt="image-20230716125923545"></p><h2 id="1-2-互联网概述"><a href="#1-2-互联网概述" class="headerlink" title="1.2 互联网概述"></a>1.2 互联网概述</h2><h3 id="1-2-1-网络的网络"><a href="#1-2-1-网络的网络" class="headerlink" title="1.2.1 网络的网络"></a>1.2.1 网络的网络</h3><p>网络&#x3D;节点（node）+链路（link）</p><p>链路有点抽象</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230716131517681.png" alt="image-20230716131517681"></p><p>多个网络——》路由器连接——》更大的网络——》网络的网络——》互连网</p><p>更多的互连网覆盖全球连接成互联网</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230716131956839.png" alt="image-20230716131956839"></p><h3 id="1-2-2-互联网基础结构发展的三个阶段"><a href="#1-2-2-互联网基础结构发展的三个阶段" class="headerlink" title="1.2.2 互联网基础结构发展的三个阶段"></a>1.2.2 互联网基础结构发展的三个阶段</h3><p>第一阶段（1965–1990）：1983年作为互联网的诞生时间，TCP&#x2F;IP协议成为APPANET的标准协议</p><p>第二阶段（1985–1993）：三级结构：主干网，地区网，校园网或者企业网</p><p>第三阶段（1993–至今）： 多层isp结构：主干isp，地区isp，本地isp</p><p>isp就是卖卡的运营商:smile:&#x2F;&#x2F;</p><p>（isp ix：互联网交换点）</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230716132040781.png" alt="image-20230716132040781"></p><p>cp就是b站这种</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230716133419473.png" alt="image-20230716133419473"></p><p>*一些历史</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230716133634489.png" alt="image-20230716133634489"></p><h3 id="1-2-3-互联网的标准化工作"><a href="#1-2-3-互联网的标准化工作" class="headerlink" title="1.2.3 互联网的标准化工作"></a>1.2.3 互联网的标准化工作</h3><p>管理金字塔：<img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230716133852203.png" alt="image-20230716133852203"></p><p>发表格式：<img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230716133959590.png" alt="image-20230716133959590"></p><p>标准化过程：<img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230716134141548.png" alt="image-20230716134141548"></p><h2 id="1-3-互联网的组成"><a href="#1-3-互联网的组成" class="headerlink" title="1.3 互联网的组成"></a>1.3 互联网的组成</h2><h3 id="1-3-1互联网的边缘部分"><a href="#1-3-1互联网的边缘部分" class="headerlink" title="1.3.1互联网的边缘部分"></a>1.3.1互联网的边缘部分</h3><p>工作方式分：</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230716180923056.png" alt="image-20230716180923056"></p><p>核心（服务</p><p>边缘:终端系统，例如你的手机，电脑，是网络的尽头,不负责转发</p><h4 id="计算机之间的通信："><a href="#计算机之间的通信：" class="headerlink" title="计算机之间的通信："></a>计算机之间的通信：</h4><p>主机a的某个进程与主机b的某个进程进行通信</p><h4 id="通信方式："><a href="#通信方式：" class="headerlink" title="通信方式："></a>通信方式：</h4><p>1.客户-服务器方式（c&#x2F;s方式）</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230716182252086.png" alt="image-20230716182252086"></p><p>客户主动，服务被动，通信是双向的</p><p>特点：<img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230716182549951.png" alt="image-20230716182549951"></p><p>2.对等连接方式（p2p方式–cs升级版）</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230716193447000.png" alt="image-20230716193447000"></p><p>既能请求又能提供服务，平等对等通信</p><h3 id="1-3-2-互联网的核心部分"><a href="#1-3-2-互联网的核心部分" class="headerlink" title="1.3.2*互联网的核心部分"></a>1.3.2*互联网的核心部分</h3><ul><li><p>复杂部分</p></li><li><p>连接边缘的主机</p><p>路由器（router）–&gt;实现分组交换的关键构件</p></li></ul><h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><h5 id="三个阶段："><a href="#三个阶段：" class="headerlink" title="三个阶段："></a>三个阶段：</h5><ul><li>建立连接：占用通信资源</li><li>通话：一直占用通信资源</li><li>连接释放：归还通信资源</li></ul><p>！！！要一直占用才算电路交换</p><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ol><li>通信时延小。因为通信线路为通信双方用户专用，数据直达，因此通信时延非常小，当<strong>连续传输大量数据</strong>时，这一优点非常明显。</li><li><strong>有序传输</strong>。因为通信双方之间只有一条专用的通信线路，数据只在这一条线路上传输，因此不存在失序问题。</li></ol><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>1.<strong>建立连接时间长</strong>。电路交换的平均连接建立时间对计算机通信来说太长。</p><p>2.线路独占，使用<strong>效率低</strong>。电路交换一旦建立连接，物理通路就被通信双方独占，即使通信线路空闲，也不能够供其他用户使用，因而信道利用率很低。 </p><p>3.<strong>灵活性差</strong>。只要连接所建立的物理通路中的任何一点出现了故障，就必须重新拨号建立新的连接，这对十分紧急和重要的通信是很不利的。</p><p>4.难以规格化。电路交换时，数据直达，不同类型、不同规格、不同速率的终端很难相互进行通信，也难以在通信中进行差错控制。</p><h4 id="分组交换："><a href="#分组交换：" class="headerlink" title="分组交换："></a>分组交换：</h4><h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><ul><li>采用储存转发技术</li></ul><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230716200204320.png" alt="image-20230716200204320"></p><h5 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230716201153174.png" alt="image-20230716201153174"></p><ul><li>数据段前面添加首部就构成了分组（packet）</li></ul><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230716200136812.png" alt="image-20230716200136812"></p><p>这个部分的不同称呼）））</p><p>物理层数据包: 比特流 (bit stream)<br>链路层数据包:帧 (frame)<br>网络层数据包: IP 数据报或分组 (packet)<br>运输层数据包: TCP 报文段 (segment) 或<br>UDP 用户数据报 (datagram)<br>应用层数据包: 报文 (message)</p><p>*首部由不同的协议决定</p><ul><li><p>接收到后去掉首部并且还原</p></li><li><p>每个分组独立选择传输路径</p></li></ul><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230716201920058.png" alt="image-20230716201920058"></p><p>高效、灵活、迅速、可靠</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230716202046591.png" alt="image-20230716202046591"></p><p>排队、带宽不确定、开销大</p><p>10个字节利用率为百分之90</p><h4 id="报文交换："><a href="#报文交换：" class="headerlink" title="报文交换："></a>报文交换：</h4><h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><ol><li><strong>无需建立连接</strong>。报文交换不需要为通信双方预先建立一条专用的通信线路，不存在建立连接的时延，用户可以随时发送报文。</li><li><strong>动态分配线路</strong>。当发送方把报文传送给节点交换机时，节点交换机先存储整个报文，然后选择一条合适的空闲线路，将报文发送出去。</li><li><strong>可靠性。</strong>如果某条传输路径发送故障，会重新选择另一条路径传输数据，因此提高了传输的可靠性。</li><li><strong>提高线路利用率</strong>。通信双方不是固定占用一条通信线路，而是在不同的时间分段部分占用物理线路，因而大大提高了通信线路的利用率。</li></ol><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ol><li>引起了转发<strong>时延</strong>。这是因为报文在节点交换机上要<em>经历存储转发的过程</em>。</li><li>需要较大的存储缓存空间。这是因为报文交换<strong>对报文的大小没有限制</strong>。</li><li>需要传输额外的信息量。这是因为报文<strong>需要携带目的地址、源地址等信息。</strong></li></ol><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230716202236271.png" alt="image-20230716202236271"></p><p>直观体现分组交换的便利快捷</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230716202442974.png" alt="image-20230716202442974"></p><h2 id="1-4计算机在我国的发展"><a href="#1-4计算机在我国的发展" class="headerlink" title="1.4计算机在我国的发展"></a>1.4计算机在我国的发展</h2><p>*一些历史</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230717101308796.png" alt="image-20230717101308796"></p><p>cn规模最大的五个计算机网络</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230717101458456.png" alt="image-20230717101458456"></p><h2 id="1-5-计算机网络的类别"><a href="#1-5-计算机网络的类别" class="headerlink" title="1.5 计算机网络的类别"></a>1.5 计算机网络的类别</h2><h3 id="1-5-1-计算机网络的定义"><a href="#1-5-1-计算机网络的定义" class="headerlink" title="1.5.1 计算机网络的定义"></a>1.5.1 计算机网络的定义</h3><p>未统一定义，有通俗定义（怎么连接？怎么管理？怎么共享？）</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230717103507953.png" alt="image-20230717103507953"></p><h3 id="1-5-2-几种不同类别的计算机网络"><a href="#1-5-2-几种不同类别的计算机网络" class="headerlink" title="1.5.2 几种不同类别的计算机网络"></a>1.5.2 几种不同类别的计算机网络</h3><ul><li>按作用范围分</li></ul><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230717103752857.png" alt="image-20230717103752857"></p><ul><li>按使用者分</li></ul><p>公用网（public）和专用网(private)</p><ul><li>接入网</li></ul><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230717104426936.png" alt="image-20230717104426936"></p><h2 id="1-6-计算机网络的性能"><a href="#1-6-计算机网络的性能" class="headerlink" title="1.6*计算机网络的性能"></a>1.6*计算机网络的性能</h2><h3 id="1-6-1-计算机网络的性能指标"><a href="#1-6-1-计算机网络的性能指标" class="headerlink" title="1.6.1* 计算机网络的性能指标"></a>1.6.1* 计算机网络的性能指标</h3><h4 id="1-速率（香农）"><a href="#1-速率（香农）" class="headerlink" title="1.速率（香农）"></a>1.速率（香农）</h4><ul><li>比特是成为信息的基本单位</li><li>速率指的是数据的传送速率，称为数据率或者比特率</li><li>单位：bit&#x2F;s  kbit&#x2F;s  Mbit&#x2F;s  Gbit&#x2F;s（速率的换算为10的三次方，数据量的换算为2的10次方）</li><li>为理想状态额定功率</li></ul><h4 id="2-带宽（bandwidth）"><a href="#2-带宽（bandwidth）" class="headerlink" title="2.带宽（bandwidth）"></a>2.带宽（bandwidth）</h4><p>频域与时域（？）</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230725171202338.png" alt="image-20230725171202338"></p><p>下载速度用字节表示，带宽用比特表示</p><p>指网络系统的通信<strong>链路</strong>（与信道或者传输媒体同意）传输数据的能力，即表征单位时间内从网络中的某一点到另一点所能通过的”<strong>最高数据率</strong>“。单位是bit&#x2F;s</p><h4 id="3-吞吐量（略）"><a href="#3-吞吐量（略）" class="headerlink" title="3.吞吐量（略）"></a>3.吞吐量（略）</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230725172027073.png" alt="image-20230725172027073"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230725172045324.png" alt="image-20230725172045324"></p><p>吞吐量降低会感觉到时延</p><h4 id="4-时延（delay）"><a href="#4-时延（delay）" class="headerlink" title="4.时延（delay）"></a>4.时延（delay）</h4><h5 id="1-发送时延（终端）"><a href="#1-发送时延（终端）" class="headerlink" title="1.发送时延（终端）"></a>1.发送时延（终端）</h5><p>*数据从电脑等发送到网络上，与数据量和带宽有关(带宽提高发送时延降低)</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230725175506604.png" alt="image-20230725175506604"></p><p>公式：<br>$$<br>发送时延&#x3D;数据帧长度(bit)&#x2F;发送速率(bit&#x2F;s)<br>$$<br>发射时延与传输距离没有关系</p><h5 id="2-传播时延（线路）"><a href="#2-传播时延（线路）" class="headerlink" title="2.传播时延（线路）"></a>2.传播时延（线路）</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230725175843073.png" alt="image-20230725175843073"></p><p>传播时延与传播距离有关，与发送速率无关，因为一般来说速率是固定的</p><h5 id="3-处理时延和排队时延（路由器）"><a href="#3-处理时延和排队时延（路由器）" class="headerlink" title="3.处理时延和排队时延（路由器）"></a>3.处理时延和排队时延（路由器）</h5><p>*排队时延和处理时延是息息相关的</p><p>*当排队时延无限大时，数据会爆，这是很糟糕的情况</p><p>*处理时延是主机或路由器处理分组花的时间</p><p>*排队时延是排队等待处理的时间花费</p><h5 id="4-时延带宽积"><a href="#4-时延带宽积" class="headerlink" title="4.时延带宽积"></a>4.时延带宽积</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230725181859712.png" alt="image-20230725181859712"></p><p>带宽是线路的横截面积，时延是长度，单位是比特，表示数据栈排满能装多少数据 （发了，但对方还没接收到的数据量）</p><h5 id="总时延"><a href="#总时延" class="headerlink" title="总时延"></a>总时延</h5><p>总时延&#x3D;发送时延+传播时延+排队时延+处理时延</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230725181042881.png" alt="image-20230725181042881"></p><h4 id="5-往返时间RTT（round-trip-time）"><a href="#5-往返时间RTT（round-trip-time）" class="headerlink" title="5.往返时间RTT（round-trip time）"></a>5.往返时间RTT（round-trip time）</h4><p>从发送完数据到确认接收完数据的时间</p><p>（传输时延+处理时延+返回时延）</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230725195443604.png" alt="image-20230725195443604"></p><p>相关公式：<br>$$<br>有效数据率&#x3D;数据长度&#x2F;(发送时间+RTT)&#x3D;数据长度&#x2F;总时延<br>$$</p><h4 id="6-利用率"><a href="#6-利用率" class="headerlink" title="6.利用率"></a>6.利用率</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230725200730902.png" alt="image-20230725200730902"></p><p>利用率指的是有多少信道正在被利用</p><p>时延带宽积是指完全使用时有多少空位可以让数据等待</p><ul><li>利用率越大时延越大，不是越大越好，需要一定的容错（一般在30-50%，超过70%认为拥挤）</li></ul><h3 id="1-6-2计算机网络的非性能特征"><a href="#1-6-2计算机网络的非性能特征" class="headerlink" title="1.6.2计算机网络的非性能特征"></a>1.6.2计算机网络的非性能特征</h3><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230725202926390.png" alt="image-20230725202926390"></p><h2 id="1-7-计算机的体系结构"><a href="#1-7-计算机的体系结构" class="headerlink" title="1.7*计算机的体系结构"></a>1.7*计算机的体系结构</h2><h4 id="1-7-1计算机网络体系结构的形成"><a href="#1-7-1计算机网络体系结构的形成" class="headerlink" title="1.7.1计算机网络体系结构的形成"></a>1.7.1计算机网络体系结构的形成</h4><p>*因为差别多需要统一的结构便于沟通</p><p>*将大问题通过分层变成若干个小问题</p><p>1983年ISO 7498标准</p><p><strong>OSI</strong></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230725204046783.png" alt="image-20230725204046783"></p><h4 id="1-7-2协议与划分层次"><a href="#1-7-2协议与划分层次" class="headerlink" title="1.7.2协议与划分层次"></a>1.7.2协议与划分层次</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230725204220292.png" alt="image-20230725204220292"></p><p>工作分层，设定规则</p><h5 id="协议（语法、语义、同步-x2F-时序）"><a href="#协议（语法、语义、同步-x2F-时序）" class="headerlink" title="协议（语法、语义、同步&#x2F;时序）"></a>协议（语法、语义、同步&#x2F;时序）</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230725204325136.png" alt="image-20230725204325136"></p><p>协议分为文字描述和代码描述</p><h5 id="划分层次（理解不能）"><a href="#划分层次（理解不能）" class="headerlink" title="划分层次（理解不能）"></a>划分层次（理解不能）</h5><h6 id="分层要求"><a href="#分层要求" class="headerlink" title="分层要求"></a>分层要求</h6><ul><li>层次适度</li><li>功能确定</li><li>层次独立</li><li>层次关联</li><li>层次对等</li><li>层次协议</li><li>层次接口</li></ul><h6 id="层次功能"><a href="#层次功能" class="headerlink" title="层次功能"></a>层次功能</h6><ul><li>差错控制</li><li>流量控制</li><li>分段和重装</li><li>复用和分用</li><li>逻辑连接的建立和释放</li></ul><h4 id="1-7-3具有五层协议的体系结构"><a href="#1-7-3具有五层协议的体系结构" class="headerlink" title="1.7.3具有五层协议的体系结构"></a>1.7.3具有五层协议的体系结构</h4><p>osi<strong>不适合市场</strong>因此被淘汰了，取而代之的是由市场选择的<strong>事实上的国际标准</strong>（TCP&#x2F;IP），分为应用层、运输层、互联网层、网络接口层</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230725210708216.png" alt="image-20230725210708216"></p><p>缺点</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230725211115327.png" alt="image-20230725211115327"></p><p>实际教学为5层结构</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230725211349577.png" alt="image-20230725211349577"></p><p>先大体过一下每个层次的功能</p><ul><li>应用层</li></ul><p>用户之间</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230725211621386.png" alt="image-20230725211621386"></p><ul><li>运输层(TCP&#x2F;UDP)</li></ul><p>进程之间</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230725211705488.png" alt="image-20230725211705488"></p><ul><li>网络层（IP）</li></ul><p>主机之间</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230725211812661.png" alt="image-20230725211812661"></p><ul><li>数据链路层</li></ul><p>相邻节点之间</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230725212835168.png" alt="image-20230725212835168"></p><ul><li><p>物理层</p><p>传比特<img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230725213023391.png" alt="image-20230725213023391"></p></li></ul><p>通信示例：<img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230725213651601.png" alt="image-20230725213651601"></p><p>（路由器也有应用层这些，但实际应用不使用）</p><h4 id="1-7-4实体、协议、服务和服务访问点"><a href="#1-7-4实体、协议、服务和服务访问点" class="headerlink" title="1.7.4实体、协议、服务和服务访问点"></a>1.7.4实体、协议、服务和服务访问点</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230725213905325.png" alt="image-20230725213905325"></p><p> *协议沟通同一层次的实体，对上层透明</p><p>*服务访问点用于相邻两层的实体进行交换信息，本质上是一个逻辑接口</p><p>*服务是垂直的</p><p>*<strong>上层以为他们直接靠协议进行通信，实际上是上层在使用下层的服务，下层对上层来说是透明的</strong></p><h4 id="1-7-5-TCP-x2F-IP的体系结构（实际）"><a href="#1-7-5-TCP-x2F-IP的体系结构（实际）" class="headerlink" title="1.7.5 TCP&#x2F;IP的体系结构（实际）"></a>1.7.5 TCP&#x2F;IP的体系结构（实际）</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230725215853688.png" alt="image-20230725215853688"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230725215920283.png" alt="image-20230725215920283">核心部分越简单越好</p><h4 id="体系结构对比"><a href="#体系结构对比" class="headerlink" title="体系结构对比"></a>体系结构对比</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230802235901147.png" alt="image-20230802235901147"></p><h1 id="第二节：物理层"><a href="#第二节：物理层" class="headerlink" title="第二节：物理层"></a>第二节：物理层</h1><h2 id="2-1-物理层的基本概念"><a href="#2-1-物理层的基本概念" class="headerlink" title="2.1 物理层的基本概念"></a>2.1 物理层的基本概念</h2><ul><li>位置：网络体系结构的最底层（不是具体的传输媒体，也不是连接计算机的具体物理设备</li><li>功能：<img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230726202057797.png" alt="image-20230726202057797"></li></ul><p>接收，编码，传输</p><ul><li><p>作用：屏蔽掉不同传输媒体和通信手段的差异（将同一句话说给不同的人）</p></li><li><p>主要任务：确定与传输媒体的接口有关的一些特性</p></li><li><p>物理层协议是DTE和DCE间的约定，具有以下特性：</p></li></ul><ol><li>机械特性（长什么样）</li><li>电气特性（用多少电平，电阻之类）</li><li>功能特性（每根线的作用）</li><li>过程特性（各种事件的出现顺序）</li></ol><h2 id="2-2-数据通信的基础知识"><a href="#2-2-数据通信的基础知识" class="headerlink" title="2.2 数据通信的基础知识"></a>2.2 数据通信的基础知识</h2><h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语:"></a>基本术语:</h3><ol><li>通信：在源点和终点之间传递消息或者信息（消息不等于信息）</li><li>消息：能被通信双方理解而且可以相互传递的文字、符号、数据、语音和图像等</li><li><strong>信息</strong>:消息中的有意义的部分，<strong>消息是信息的载体</strong>(关键)</li><li>数据：运送消息的实体，分为模拟数据和数字数据</li><li>信号：是消息的载体，通信系统中消息通过电信号传递，分为模拟信号和数字信号</li></ol><p>栗子:我发了一段乱码给小米，我们在通信，我发的是消息，但是小明看得懂每个字，但是连在一起就不会了，这段话对他没有意义，他也就没收到信息，乱码中有字母数字等为数据，在路线中通过电信号传递</p><p>画个示意图整理概念：</p><p><strong><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230726213808371.png" alt="image-20230726213808371"></strong></p><h3 id="常见编码方式"><a href="#常见编码方式" class="headerlink" title="常见编码方式"></a>常见编码方式</h3><ul><li><p>不归零制（不确定·比特数）</p></li><li><p>归零制（跳变后归零）</p></li><li><p>曼切斯特编码（由上升沿或者下降沿作为0或1）</p></li><li><p>差分曼切斯特编码（由下一个比特状态确定，下一个是0边缘跳变，否则不变）</p><p><strong>特点</strong></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230726230337759.png" alt="image-20230726230337759"></p></li></ul><h3 id="基本带通调制方法"><a href="#基本带通调制方法" class="headerlink" title="基本带通调制方法"></a>基本带通调制方法</h3><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230726230632971.png" alt="image-20230726230632971"></p><p>调幅：不同信号用不同幅度的波形替代（高低电平幅度不同）</p><p>调频：高低电平频率不同</p><p>调相：高低电平相位不同</p><h3 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h3><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230726231645991.png" alt="image-20230726231645991"></p><h3 id="2-2-1-数据通信系统的模型"><a href="#2-2-1-数据通信系统的模型" class="headerlink" title="2.2.1 数据通信系统的模型"></a>2.2.1 数据通信系统的模型</h3><p>  源系统(信源和发送器)</p><p>传输系统</p><p>目的系统(接收器和信宿)</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230726211024317.png" alt="image-20230726211024317"></p><h3 id="2-2-2-有关信道的几个基本概念"><a href="#2-2-2-有关信道的几个基本概念" class="headerlink" title="2.2.2 有关信道的几个基本概念"></a>2.2.2 有关信道的几个基本概念</h3><ul><li>信道：信号传输的通道（单工、半双工、全双工通信）</li><li>基带信号（未调制，较多低频）</li><li>调制（基带调制和带通调制）</li></ul><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230726211736738.png" alt="image-20230726211736738"></p><p>基带调制（编码coding）—改装自行车</p><p>带通调制—自行车放在大货车上、</p><h3 id="2-2-3-信道的极限容量"><a href="#2-2-3-信道的极限容量" class="headerlink" title="2.2.3 信道的极限容量"></a>2.2.3 信道的极限容量</h3><p>信道传输信号会失真</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230726231845885.png" alt="image-20230726231845885"></p><p>失真原因：</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230726232158449.png" alt="image-20230726232158449"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230726232222015.png" alt="image-20230726232222015"></p><p>信噪比：信号和噪声的比值</p><h4 id="信道的频率范围"><a href="#信道的频率范围" class="headerlink" title="信道的频率范围"></a>信道的频率范围</h4><h4 id="奈氏准则（理想情况）"><a href="#奈氏准则（理想情况）" class="headerlink" title="奈氏准则（理想情况）"></a>奈氏准则（理想情况）</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230726232653280.png" alt="image-20230726232653280"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230726235024390.png" alt="image-20230726235024390"> </p><h4 id="信噪比"><a href="#信噪比" class="headerlink" title="信噪比"></a>信噪比</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230726233449890.png" alt="image-20230726233449890"></p><p>s———signal</p><p>n———noise</p><h4 id="香农公式！！！！"><a href="#香农公式！！！！" class="headerlink" title="香农公式！！！！"></a>香农公式！！！！</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230726233652065.png" alt="image-20230726233652065"></p><p>将信噪比考虑进去了，只要速率低于这个值就一定能找到传输方式减少差错</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230726234017828.png" alt="image-20230726234017828"></p><p><strong>奈氏是上限，香农是下限</strong> </p><p><strong>奈氏考虑码制，香农考虑信噪比</strong></p><h2 id="2-3-物理层下面的传输媒体"><a href="#2-3-物理层下面的传输媒体" class="headerlink" title="2.3 物理层下面的传输媒体"></a>2.3 物理层下面的传输媒体</h2><h3 id="2-3-1-导引型传输媒体"><a href="#2-3-1-导引型传输媒体" class="headerlink" title="2.3.1 导引型传输媒体"></a>2.3.1 导引型传输媒体</h3><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230727202119189.png" alt="image-20230727202119189"></p><p>*有线–网线等</p><h4 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h4><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>twist起来可以减少信号辐射</p><p>A&#x2F;D信号都可以传输 </p><p>一般来说默认最高传输距离为100m</p><p>便宜</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230727202737489.png" alt="image-20230727202737489"></p><h5 id="类别差别"><a href="#类别差别" class="headerlink" title="类别差别"></a>类别差别</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230727202810661.png" alt="image-20230727202810661"><strong>屏蔽更安全</strong></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230727203032556.png" alt="image-20230727203032556"></p><p>F&#x2F;UTP最外层</p><p>U&#x2F;FTP里层</p><p>F&#x2F;FTP双层</p><h5 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230727203754882.png" alt="image-20230727203754882"></p><p>8类线，负责传输电磁波信号</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230727203910384.png" alt="image-20230727203910384"></p><h4 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h4><h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><p>一层包一层</p><p>被双绞线和光纤薄纱</p><p>容易被偷</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230727204822445.png" alt="image-20230727204822445"></p><h4 id="光缆"><a href="#光缆" class="headerlink" title="光缆"></a>光缆</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230727205119550.png" alt="image-20230727205119550"></p><h5 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h5><p>发送端要有光源，不能有电源（发光二极管，半导体激光器等）</p><p>接收端要有光检测器还原出电脉冲</p><h5 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h5><p>利用物理相关知识设计使得光以某个入射角入射时，光线一直在线路中进行全反射传播</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230727205628057.png" alt="image-20230727205628057"></p><h5 id="多模与单模"><a href="#多模与单模" class="headerlink" title="多模与单模"></a>多模与单模</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230727205919922.png" alt="image-20230727205919922"></p><p>多模传的多但是距离短（损耗大）</p><p>单模传的少但是长</p><h5 id="使用类别"><a href="#使用类别" class="headerlink" title="使用类别"></a>使用类别</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230727210131465.png" alt="image-20230727210131465"></p><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230727210212003.png" alt="image-20230727210212003">太脆弱了需要很多保护层</p><h3 id="2-3-2-非导引型传输媒体"><a href="#2-3-2-非导引型传输媒体" class="headerlink" title="2.3.2 非导引型传输媒体"></a>2.3.2 非导引型传输媒体</h3><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230727202135018.png" alt="image-20230727202135018"></p><p>*无线–wifi</p><h4 id="无线电微波通信"><a href="#无线电微波通信" class="headerlink" title="无线电微波通信"></a>无线电微波通信</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230727211708263.png" alt="image-20230727211708263"></p><p>通过微波接力扩大传输距离（地面和太空）</p><h4 id="同步卫星"><a href="#同步卫星" class="headerlink" title="同步卫星"></a>同步卫星</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230727212445803.png" alt="image-20230727212445803"></p><h4 id="近地卫星"><a href="#近地卫星" class="headerlink" title="近地卫星"></a>近地卫星</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230727212625219.png" alt="image-20230727212625219"></p><h3 id="2-4-信道复用技术"><a href="#2-4-信道复用技术" class="headerlink" title="2.4 信道复用技术"></a>2.4 信道复用技术</h3><h4 id="2-4-1-频分复用、时分复用和统计时分复用"><a href="#2-4-1-频分复用、时分复用和统计时分复用" class="headerlink" title="2.4.1 频分复用、时分复用和统计时分复用"></a>2.4.1 频分复用、时分复用和统计时分复用</h4><p>信道复用—–传输多个信号，提高信道利用率，降低成本</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230727213639106.png" alt="image-20230727213639106"></p><h6 id="频分复用（电视同一时间有不同的频道可以观看）"><a href="#频分复用（电视同一时间有不同的频道可以观看）" class="headerlink" title="频分复用（电视同一时间有不同的频道可以观看）"></a>频分复用（电视同一时间有不同的频道可以观看）</h6><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230727213835807.png" alt="image-20230727213835807"></p><p>分到哪个就只能用哪个</p><h6 id="频分多址（同一个频道轮流有不同的电视节目）"><a href="#频分多址（同一个频道轮流有不同的电视节目）" class="headerlink" title="频分多址（同一个频道轮流有不同的电视节目）"></a>频分多址（同一个频道轮流有不同的电视节目）</h6><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230727214102303.png" alt="image-20230727214102303"></p><h6 id="时分复用"><a href="#时分复用" class="headerlink" title="时分复用"></a>时分复用</h6><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230727214404250-1690465445714-1.png" alt="image-20230727214404250"></p><p>一天按一个小时为单位（TDM帧），前20分钟给a用，然后给b用，最后给c用，循环24次</p><p><strong>缺点</strong></p><p>前20分钟不管你用不用，后面的人都得等待，效率低—— </p><h6 id="时分多址"><a href="#时分多址" class="headerlink" title="时分多址"></a>时分多址</h6><p>前20分钟不单单给a用，也可以给a的好朋友efg用</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230727214859241.png" alt="image-20230727214859241"></p><h5 id="统计时分复用"><a href="#统计时分复用" class="headerlink" title="统计时分复用"></a>统计时分复用</h5><p>前面说了时分复用会让利用率降低，那么统计时分就是在此基础上添加新补丁的版本</p><p> 将原本的TDM帧升级为STDM帧，通过复用器将每个部分进行扫描，有数据则存入STDM中，当帧满时再发送</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230727224015005.png" alt="image-20230727224015005"></p><h4 id="2-4-2-（光）波分复用"><a href="#2-4-2-（光）波分复用" class="headerlink" title="2.4.2 （光）波分复用"></a>2.4.2 （光）波分复用</h4><p>其实就是光波的频分复用，只不过这里的频率指的是光波的波长</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230727224336036.png" alt="image-20230727224336036"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230727224415679.png" alt="image-20230727224415679"></p><h4 id="2-4-3-码分复用（码分多址）"><a href="#2-4-3-码分复用（码分多址）" class="headerlink" title="2.4.3 码分复用（码分多址）"></a>2.4.3 码分复用（码分多址）</h4><p>前面的时分和波分复用都是固定了时间或者频率范围进行描述的，而码分复用就是要求时间及频率都相同的情况下如何进行码分复用，很简单，就是给不同的游客分发不同的牌证在同一辆车上跑，等下车时看牌分人</p><p><em><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230727225132254.png" alt="image-20230727225132254"></em>*</p><h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230727225745816.png" alt="image-20230727225745816"></p><p>将原来的0和1扩展内核变成一个m位的二进制数，例如1101代表1，那么它的反码0010就是表示0</p><p>为了便于计算，码片的0表示成-1，1就是1</p><p><strong>为了能复用传输的东西也扩大了m倍</strong></p><h6 id="如何区分不同码片？"><a href="#如何区分不同码片？" class="headerlink" title="如何区分不同码片？"></a>如何区分不同码片？</h6><p>类比数学上的向量内积</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230727230407485.png" alt="image-20230727230407485"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230727230416910.png" alt="image-20230727230416910"></p><h6 id="怎么从合并信号中分离出单一信号？"><a href="#怎么从合并信号中分离出单一信号？" class="headerlink" title="怎么从合并信号中分离出单一信号？"></a>怎么从合并信号中分离出单一信号？</h6><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230727231251326.png" alt="image-20230727231251326"></p><p>首先确定两个码片的波形，然后将两个信号叠加起来（算数），最后将信号分离时需要哪一个信号就将合并的信号与其码片进行内积计算，得到的波形就是我们需要的原信号（这里1代表1，0代表-1）</p><h4 id="各种复用技术的使用条件"><a href="#各种复用技术的使用条件" class="headerlink" title="各种复用技术的使用条件"></a>各种复用技术的使用条件</h4><p>频分复用适用于传输的信号在不同的频带上</p><p>时分复用适用于在不同的时间上传输的信号</p><p>波分复用适用于光信号传播</p><p><strong>码分复用适用于干扰较强时</strong></p><h1 id="第三节-数据链路层概述"><a href="#第三节-数据链路层概述" class="headerlink" title="第三节 数据链路层概述"></a>第三节 数据链路层概述</h1><h2 id="3-1-1-关于数据链路层"><a href="#3-1-1-关于数据链路层" class="headerlink" title="3.1.1 关于数据链路层"></a>3.1.1 关于数据链路层</h2><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><pre><code>    1.在比特流中找到一组数据的开始以及结束位置    2.解决多个设备接收比特流问题    3.**解决比特传输错误问题** </code></pre><h3 id="链路、数据链路、层、帧"><a href="#链路、数据链路、层、帧" class="headerlink" title="链路、数据链路、层、帧"></a>链路、数据链路、层、帧</h3><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230801160555027.png" alt="image-20230801160555027"></p><p>链路：物理且无源</p><p>数据链路&#x3D;链路+协议</p><p>层：将结点与结点之间通过链路传输帧</p><p>帧：分组交换的单位到了链路层被叫做帧 </p><h3 id="协议栈看数据链路层"><a href="#协议栈看数据链路层" class="headerlink" title="协议栈看数据链路层"></a>协议栈看数据链路层</h3><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230801160948245.png" alt="image-20230801160948245"></p><p>层对层，无视下层（透明），服务上层，看做直接传输帧通信</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230801161140434.png" alt="image-20230801161140434"></p><h3 id="数据链路层的信道类型"><a href="#数据链路层的信道类型" class="headerlink" title="数据链路层的信道类型"></a>数据链路层的信道类型</h3><ol><li>点对点信道（骨干线路）</li></ol><ul><li><input disabled type="checkbox"> 使用协议？</li></ul><p>PPP</p><ol><li>广播通信（边缘线路）</li></ol><ul><li><input disabled type="checkbox"> 使用协议？</li></ul><p>CSMA&#x2F;CD</p><h2 id="3-1-2-三个基本问题"><a href="#3-1-2-三个基本问题" class="headerlink" title="3.1.2 三个基本问题"></a>3.1.2 三个基本问题</h2><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p><strong>比特流前加首部和尾部进行帧定界</strong></p><p><em>数据链路层往上只加首部</em></p><p>MTU（Maximum Transfer Unit）—帧的数据部分最长限制&#x2F;IP数据报长度（图片蓝色部分）</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230801162117153.png" alt="image-20230801162117153"></p><p>规定原因：（）</p><h4 id="成帧-FRAMING-方式"><a href="#成帧-FRAMING-方式" class="headerlink" title="成帧(FRAMING)方式"></a>成帧(FRAMING)方式</h4><ul><li><strong>字节计数法（无差错情况）</strong></li></ul><p>出错会导致一连串帧的错误</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230801162707892.png" alt="image-20230801162707892"></p><ul><li><strong>带字节填充的定界符法</strong></li></ul><p>SOH（首部）与EOT（尾部）</p><p>数据部分若有与SOH或EOT相同的部分则会错误判断帧的边界</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230801163037221.png" alt="image-20230801163037221">升级版：<strong>在有歧义的数据前面加上特殊字节或者字符</strong></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230801163526670.png" alt="image-20230801163526670"></p><ul><li><strong>带比特填充的定界符法</strong></li><li><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230801164114484.png" alt="image-20230801164114484"></li><li><strong>物理层编码违例</strong></li><li><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230801164129689.png" alt="image-20230801164129689"></li></ul><h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><p>翻译：发送不发生差错</p><p>利用前面的插入方式使得传输正确</p><h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><h4 id="误码率（BER）"><a href="#误码率（BER）" class="headerlink" title="误码率（BER）"></a>误码率（BER）</h4><p>错误的比特占传输比特的总数</p><h4 id="纠错码（改）"><a href="#纠错码（改）" class="headerlink" title="纠错码（改）"></a>纠错码（改）</h4><p>使用于错误发生比较频繁的线路（无线链路）</p><h4 id="检错码（丢）"><a href="#检错码（丢）" class="headerlink" title="检错码（丢）"></a>检错码（丢）</h4><p>用在高可靠、误码率较低的信道上，例如光纤线路（光纤线路）</p><h4 id="循环冗余检验CRC原理"><a href="#循环冗余检验CRC原理" class="headerlink" title="循环冗余检验CRC原理"></a>循环冗余检验CRC<strong>原理</strong></h4><ol><li><p>在原来的数据部分（k位）加上n位的冗余码（FCS）构成帧</p></li><li><p>整体有错丢弃反之接收</p></li><li><p>计算方式：<img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230801165716585.png" alt="image-20230801165716585"></p></li><li><p>栗子：<img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230801171636250.png" alt="image-20230801171636250"></p><pre><code> 这种应该是通过代码程序实现![image-20230801171652908](https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230801171652908.png)</code></pre></li></ol><p>国际标准<strong>P</strong></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230801172010613.png" alt="image-20230801172010613"></p><p><em><strong>FCS不一定由CRC得到</strong></em></p><p>CRC只能做到接收到的帧没有错误，但是顺序问题不能判断</p><h2 id="3-2-点对点协议PPP"><a href="#3-2-点对点协议PPP" class="headerlink" title="3.2 点对点协议PPP"></a>3.2 点对点协议PPP</h2><h3 id="3-2-1-PPP协议的特点"><a href="#3-2-1-PPP协议的特点" class="headerlink" title="3.2.1 PPP协议的特点"></a>3.2.1 PPP协议的特点</h3><h4 id="工作要求"><a href="#工作要求" class="headerlink" title="工作要求"></a>工作要求</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230802112600769.png" alt="image-20230802112600769"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230802112720563.png" alt="image-20230802112720563"></p><p><strong>PPP不同于广播在于它会进行地址协商</strong></p><h4 id="协议组成"><a href="#协议组成" class="headerlink" title="协议组成"></a>协议组成</h4><p>LCP与NCP</p><p>LCP(Link Control Protocol)：链路控制协议—-用于建立、配置和测试数据链路的链路控制协议，双方可以<strong>协商一些选项</strong>，<strong>最重要****的功能之一是</strong>身份验证**</p><p>NCP（Network Control Protocol）:里面包括了不同的协议，用于不同网络层的数据传输</p><h3 id="3-2-2-PPP协议的帧格式"><a href="#3-2-2-PPP协议的帧格式" class="headerlink" title="3.2.2 PPP协议的帧格式"></a>3.2.2 PPP协议的帧格式</h3><h4 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230802113938474.png" alt="image-20230802113938474"></p><h4 id="透明传输方式"><a href="#透明传输方式" class="headerlink" title="透明传输方式"></a>透明传输方式</h4><h5 id="异步传输—字节填充法"><a href="#异步传输—字节填充法" class="headerlink" title="异步传输—字节填充法"></a>异步传输—字节填充法</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230802114528795.png" alt="image-20230802114528795"></p><p>IP数据报里面与首位尾部一样的字节(7E)前面填充一个特殊字节，例如7D，然后IP数据报中原来就有的7E改为别的特殊字节例如5E</p><h5 id="同步传输—零比特传输法"><a href="#同步传输—零比特传输法" class="headerlink" title="同步传输—零比特传输法"></a>同步传输—零比特传输法</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230802114935943.png" alt="image-20230802114935943"></p><p>标志符是六个一，为了不让IP数据报中出现6个1，在传输数据时当出现连续的5个1时添加一个0（与后面数据无关），接收同理出现连续的五个1则删除接下来的那个比特</p><h4 id="同步异步区别"><a href="#同步异步区别" class="headerlink" title="同步异步区别"></a>同步异步区别</h4><p>*同步面向比特，单位帧，时钟统一，无间隔</p><p>*异步面向字节，单位字符，效率低，高速来南路开销大</p><h3 id="3-2-3-PPP协议的工作状态"><a href="#3-2-3-PPP协议的工作状态" class="headerlink" title="3.2.3 PPP协议的工作状态"></a>3.2.3 PPP协议的工作状态</h3><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230802115318053.png" alt="image-20230802115318053"><br>（还是挺清晰的)</p><h2 id="3-3广播通信的数据链路层"><a href="#3-3广播通信的数据链路层" class="headerlink" title="3.3广播通信的数据链路层"></a>3.3广播通信的数据链路层</h2><h3 id="3-3-1-局域网的数据链路层"><a href="#3-3-1-局域网的数据链路层" class="headerlink" title="3.3.1 局域网的数据链路层"></a>3.3.1 局域网的数据链路层</h3><h4 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h4><p>具有广播功能便于拓展</p><h4 id="局域网拓扑结构"><a href="#局域网拓扑结构" class="headerlink" title="局域网拓扑结构"></a>局域网拓扑结构</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230802220608850.png" alt="image-20230802220608850"></p><h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><p>总线：</p><p>（优点）结构简单布线容易、可靠性较高，易于扩充</p><p>（缺点）所有的数据都需经过总线传送，总线成为整个网络的瓶颈；出现故障诊断较为困难。另外，由于信道共享，连接的节点不宜过多，<strong>总线自身的故障</strong>可以导致系统的崩溃</p><p>星型：</p><p>优点：结构简单、容易实现、便于管理，通常以集线器（Hub）作为中央节点，便于网络维护和网络管理</p><p>缺点：中心结点是全网络的可靠瓶颈，<strong>中心结点出现故障</strong>会导致网络的瘫痪。</p><p>环形结构：</p><p>优点：结构简单，适合使用光纤，传输距离远，传输延迟确定。</p><p>缺点：环网中的每个结点均成为网络可靠性的瓶颈，<strong>任意结点出现故障都会造成网络瘫痪</strong>，另外故障诊断也较困难。最著名的环形结构网络是令牌环网（Token Ring）</p><p>树型结构：</p><p>优点：连结简单，维护方便，适用于汇集信息的应用要求。</p><p>缺点：资源共享能力较低，可靠性不高，任何一<strong>个工作站或链路的故障都会影响整个网络的运行</strong></p><p>网状结构：</p><p>优点：系统可靠性高，比较容易扩展，但是结构复杂，每一结点都与多点进行连结，因此必须采用<strong>路由算法</strong>和<strong>流量控制</strong>方法。<strong>目前广域网基本上采用网状结构。</strong></p><p>缺点： 1、<strong>拓扑结构复杂，其安装和配置都比较困难。</strong> 2、网络控制机制复杂，必须采用路由算法和流量控制机制</p><h4 id="媒体共享技术"><a href="#媒体共享技术" class="headerlink" title="媒体共享技术"></a>媒体共享技术</h4><p>静态划分通道：频分、时分、波分、码分</p><p>（通信量大且稳定，用户少且固定，代价高，不适合局域网）</p><p>动态媒体接入控制（多点接入）：随机接入（以太网）与受控接入（轮询polling）</p><p>*<strong>为解决数据发生冲突的情况，使用动态媒体接入控制</strong></p><h4 id="以太网的两个标准"><a href="#以太网的两个标准" class="headerlink" title="以太网的两个标准"></a>以太网的两个标准</h4><ol><li><p>IEEE 802.3（有LLC协议）</p></li><li><p>DIX Ethernet V2（商用，仅有MAC协议）</p></li></ol><h4 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h4><p>计算机通过适配器（网卡）来与互联网进行通信</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230802234920407.png" alt="image-20230802234920407"></p><p>cpu找IP地址，网卡找硬件地址</p><p><strong>作用</strong></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230802235303986.png" alt="image-20230802235303986"></p><h4 id="以太网的两个重要措施"><a href="#以太网的两个重要措施" class="headerlink" title="以太网的两个重要措施"></a>以太网的两个重要措施</h4><ol><li>采用较为灵活的<strong>无连接的工作方式</strong></li><li>发送使用曼切斯特编码，便于同步</li></ol><h3 id="3-3-2-CSMA-x2F-CD协议-半双工"><a href="#3-3-2-CSMA-x2F-CD协议-半双工" class="headerlink" title="3.3.2 CSMA&#x2F;CD协议(半双工)"></a>3.3.2 CSMA&#x2F;CD协议(半双工)</h3><h4 id="工作方式-1"><a href="#工作方式-1" class="headerlink" title="工作方式"></a>工作方式</h4><p>（先听后发，边听边发，冲突停止，延迟重发） </p><ul><li>多点接入–说明是总线型网络</li><li>载波监听–边发送边监听，发前和发中都要检测</li><li>碰撞检测–判断有没有发生碰撞：检测信道上电压的变化情况，电压摆动值超过一定值认为碰撞</li></ul><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul><li>适配器立即停止发送</li><li>等待随机时间后再次发送</li></ul><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/R-C.5c28ebc76c618c86e0c3309ea79e095a" alt="CSMA/CD原理及流程图-布布扣-bubuko.com"></p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230803002133229.png" alt="image-20230803002133229"></p><p>监听反应不过来，发生碰撞到终点的时间里不能判断，而此时还在发数据，数据会发生更大的错误</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230803002420476.png" alt="image-20230803002420476"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230803002639512.png" alt="image-20230803002639512"></p><p>确实是:laughing:</p><h4 id="二进制指数退避"><a href="#二进制指数退避" class="headerlink" title="二进制指数退避"></a>二进制指数退避</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230803002804614.png" alt="image-20230803002804614"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230803002813046.png" alt="image-20230803002813046"></p><ul><li><p>二进制的名字来源于2的k次方-1那里</p></li><li><p>r&#x3D;2*k-1</p></li><li><p>T&#x3D;r*2t</p></li><li><p>k&#x3D;Min[重传次数，10]</p></li><li><p>重传16次丢弃并且高层报告</p></li></ul><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230803003354398.png" alt="image-20230803003354398"></p><p>这个64字节有历史遗留:dancer:</p><p>  <em><strong>发生碰撞后线路上的其他用户可能不知道，这时发送站会人工发送信号到线路上通知所有用户发生碰撞</strong></em></p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230803005808940.png" alt="image-20230803005808940"></p><h3 id="3-3-3-使用集线器的星型拓扑"><a href="#3-3-3-使用集线器的星型拓扑" class="headerlink" title="3.3.3 使用集线器的星型拓扑"></a>3.3.3 使用集线器的星型拓扑</h3><ul><li>传统传输媒体发展：粗同轴电缆–细同轴电缆–双绞线</li><li>双绞线对应星型拓扑，相对总线更好组网</li><li>可靠性依靠集线器（hub）</li></ul><p>*每个站到集线器的距离不超过100m</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804115517088.png" alt="image-20230804115517088"></p><p>F对应光纤</p><p><strong>特点</strong></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804115611779.png" alt="image-20230804115611779"></p><ul><li><p>逻辑上还是总线型</p></li><li><p>共享带宽</p></li><li><p>工作在物理层</p><p>​</p></li></ul><p></p><h3 id="3-3-4-以太网的信道利用率"><a href="#3-3-4-以太网的信道利用率" class="headerlink" title="3.3.4 以太网的信道利用率"></a>3.3.4 以太网的信道利用率</h3><ul><li>多个站可能会发生碰撞</li><li>碰撞后利用率低于100%</li></ul><p>计算公式：<br>$$<br>Smax&#x3D;T0&#x2F;T+t&#x3D;1&#x2F;(1+a)<br>a&#x3D;t&#x2F;T<br>其中t为争用期的一半，T为帧的发送时间<br>$$<br><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804120238964.png" alt="image-20230804120238964"></p><p>帧长路短就是好（S低于30%过载）</p><h3 id="3-3-5-以太网的MAC层"><a href="#3-3-5-以太网的MAC层" class="headerlink" title="3.3.5 以太网的MAC层"></a>3.3.5 以太网的MAC层</h3><p>*LLC层已经不用了</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804120639225.png" alt="image-20230804120639225"></p><p>就类似于你家的经纬度，固定了的</p><p>*一个接口一个网卡一个MAC地址</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a><strong>结构</strong></h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804121054951.png" alt="image-20230804121054951"></p><p>厂家就后三个字节自己定义不重复即可 </p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804121255567.png" alt="image-20230804121255567"></p><p>发一个人，发一个组，发一个班</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804125654311.png" alt="image-20230804125654311"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804125712343.png" alt="image-20230804125712343"></p><ul><li>适配器收到一个MAC帧会先用硬件检查帧中的MAC地址</li><li>是发送给自己的则接收并处理</li><li>不是发给自己的就丢弃</li><li>以<strong>混杂方式</strong>工作的有帧就收</li></ul><h4 id="MAC的帧格式"><a href="#MAC的帧格式" class="headerlink" title="MAC的帧格式"></a>MAC的帧格式</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804130016505.png" alt="image-20230804130016505"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804130025433.png" alt="image-20230804130025433"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804130203716.png" alt="image-20230804130203716"></p><h4 id="无效MAC帧"><a href="#无效MAC帧" class="headerlink" title="无效MAC帧"></a>无效MAC帧</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804130249583.png" alt="image-20230804130249583"></p><p>无效丢弃，不重传</p><h2 id="3-4-扩展的以太网"><a href="#3-4-扩展的以太网" class="headerlink" title="3.4 扩展的以太网"></a>3.4 扩展的以太网</h2><p>*扩展仍然是一个网络</p><h3 id="3-4-1-在物理层扩展以太网"><a href="#3-4-1-在物理层扩展以太网" class="headerlink" title="3.4.1 在物理层扩展以太网"></a>3.4.1 在物理层扩展以太网</h3><h4 id="使用光纤扩展（距离）"><a href="#使用光纤扩展（距离）" class="headerlink" title="使用光纤扩展（距离）"></a>使用光纤扩展（距离）</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804130815062.png" alt="image-20230804130815062"></p><h4 id="使用集线器进行扩展（用户数量）"><a href="#使用集线器进行扩展（用户数量）" class="headerlink" title="使用集线器进行扩展（用户数量）"></a>使用集线器进行扩展（用户数量）</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804130917492.png" alt="image-20230804130917492"></p><p>限制：双绞线最大距离，集线器接口数</p><p> 图示正好是一个冲突域，扩展越多冲突域越来越大</p><p><strong>优缺点</strong></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804131350009.png" alt="image-20230804131350009"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804131358658.png" alt="image-20230804131358658"></p><h3 id="3-4-2-在数据链路层扩展以太网"><a href="#3-4-2-在数据链路层扩展以太网" class="headerlink" title="3.4.2 在数据链路层扩展以太网"></a>3.4.2 在数据链路层扩展以太网</h3><p>早期网桥，现在交换机（多接口网桥）</p><h5 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h5><ul><li><p>两个都是全双工工作方式，解决了共享总线的问题</p></li><li><p>减少了碰撞域（具有并行性 ）</p></li><li><p>接口有存储器</p></li><li><p>即插即用，<strong>交换表通过自学习建立</strong></p></li><li><p>使用专用的交换结构芯片，比使用软件转发的网桥快的一</p></li><li><p>接口独享带宽，支持多类型多速率的接口</p></li></ul><h5 id="自学习"><a href="#自学习" class="headerlink" title="自学习"></a>自学习</h5><p><strong><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804132613963.png" alt="image-20230804132613963"></strong></p><h5 id="与集线器相连"><a href="#与集线器相连" class="headerlink" title="与集线器相连"></a>与集线器相连</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804132928791.png" alt="image-20230804132928791"></p><p>更新困难，集线器没有交换表，默认广播</p><h5 id="两台交换机相连"><a href="#两台交换机相连" class="headerlink" title="两台交换机相连"></a>两台交换机相连</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804133029794.png" alt="image-20230804133029794"></p><h5 id="多台交换机相连"><a href="#多台交换机相连" class="headerlink" title="多台交换机相连"></a>多台交换机相连</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804133503240.png" alt="image-20230804133503240"></p><p>可能会形成回路，导致广播风暴</p><h5 id="生成树协议"><a href="#生成树协议" class="headerlink" title="生成树协议"></a>生成树协议</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804133842252.png" alt="image-20230804133842252"></p><p>从逻辑上把两条线变成一条线（前两张图）</p><h5 id="从总线到星型以太网"><a href="#从总线到星型以太网" class="headerlink" title="从总线到星型以太网"></a>从总线到星型以太网</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804134709381.png" alt="image-20230804134709381"></p><p>从CSMA&#x2F;CD协议到全双工</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804134751497.png" alt="image-20230804134751497"></p><h3 id="3-4-3-虚拟以太网"><a href="#3-4-3-虚拟以太网" class="headerlink" title="3.4.3 虚拟以太网"></a>3.4.3 虚拟以太网</h3><h5 id="以太网的问题"><a href="#以太网的问题" class="headerlink" title="以太网的问题"></a>以太网的问题</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804134815560.png" alt="image-20230804134815560"></p><h5 id="广播域"><a href="#广播域" class="headerlink" title="广播域"></a>广播域</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804135215265.png" alt="image-20230804135215265"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804135227396.png" alt="image-20230804135227396"></p><p>冲突域：相互发信息会冲突的区域</p><p>广播域：发送消息大家都能收到的区域</p><h5 id="安全问题、管理问题"><a href="#安全问题、管理问题" class="headerlink" title="安全问题、管理问题"></a>安全问题、管理问题</h5><p>在一个广播域不想让某些用户接收到消息</p><h5 id="解决方法：虚拟局域网VLAN（Virtual-LAN）"><a href="#解决方法：虚拟局域网VLAN（Virtual-LAN）" class="headerlink" title="解决方法：虚拟局域网VLAN（Virtual LAN）"></a>解决方法：虚拟局域网VLAN（Virtual LAN）</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804135545399.png" alt="image-20230804135545399"></p><p>只是局域网的一种服务，是一种协议，不是新型的局域网</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804135807660.png" alt="image-20230804135807660"></p><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804140138213.png" alt="image-20230804140138213"></p><h5 id="划分标准"><a href="#划分标准" class="headerlink" title="划分标准"></a>划分标准</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804140242934.png" alt="image-20230804140242934"></p><p>一般基于端口</p><h2 id="3-5-高速以太网（介绍）"><a href="#3-5-高速以太网（介绍）" class="headerlink" title="3.5 高速以太网（介绍）"></a>3.5 高速以太网（介绍）</h2><h3 id="3-5-1-100BASE-T-以太网"><a href="#3-5-1-100BASE-T-以太网" class="headerlink" title="3.5.1 100BASE-T 以太网"></a>3.5.1 100BASE-T 以太网</h3><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804140538329.png" alt="image-20230804140538329"></p><p><strong>特点</strong></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804140711348.png" alt="image-20230804140711348"></p><h3 id="3-5-2-吉比特以太网"><a href="#3-5-2-吉比特以太网" class="headerlink" title="3.5.2 吉比特以太网"></a>3.5.2 吉比特以太网</h3><p><strong>特点</strong></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804140737933.png" alt="image-20230804140737933"></p><h3 id="3-5-3-10吉比特以太网（10GE）和更快的以太网"><a href="#3-5-3-10吉比特以太网（10GE）和更快的以太网" class="headerlink" title="3.5.3 10吉比特以太网（10GE）和更快的以太网"></a>3.5.3 10吉比特以太网（10GE）和更快的以太网</h3><p><strong>特点</strong><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804140817558.png" alt="image-20230804140817558"></p><h3 id="3-5-4-使用以太网进行宽带接入"><a href="#3-5-4-使用以太网进行宽带接入" class="headerlink" title="3.5.4 使用以太网进行宽带接入"></a>3.5.4 使用以太网进行宽带接入</h3><p><strong>特点</strong></p><p><strong><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804140849208.png" alt="image-20230804140849208"></strong></p><h1 id="第一次考试纠错"><a href="#第一次考试纠错" class="headerlink" title="第一次考试纠错"></a>第一次考试纠错</h1><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804191349420.png" alt="image-20230804191349420"></p><p>电路交换比其他两种方式实时性都要高，分组交换主要是 时延比报文小</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804191638121.png" alt="img"></p><p>局域网是分组广播式网络，不需要网络层的路由功能</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804191934268.png" alt="image-20230804191934268"></p><p>审题！！！这里说的是三层以下，即是1，2层，网桥交换机是数据链路层的，中继器和集线器是物理层的</p><p>三层的是三层交换机</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230804192126631.png" alt="image-20230804192126631"></p><p>A给B发送消息，<strong>B要回复A是否收到消息了</strong>（题目没说就忽视了）</p><h1 id="第四章-网络层"><a href="#第四章-网络层" class="headerlink" title="第四章 网络层"></a>第四章 网络层</h1><h2 id="网络层解决了什么问题"><a href="#网络层解决了什么问题" class="headerlink" title="网络层解决了什么问题"></a>网络层解决了什么问题</h2><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230808141049355.png" alt="image-20230808141049355"></p><h2 id="4-1-网络层提供的两种服务"><a href="#4-1-网络层提供的两种服务" class="headerlink" title="4.1 网络层提供的两种服务"></a>4.1 网络层提供的两种服务</h2><p>观点一：网络负责可靠交付（虚电路———逻辑链接）</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806211230128.png" alt="image-20230806211230128"></p><p>很容易发生数据的丢失</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806211535386.png" alt="image-20230806211535386"></p><p>观点二：网络提供数据报服务</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806211626416.png" alt="image-20230806211626416"></p><p><strong>由更高层负责可靠通信（运输层）</strong></p><p>问题是会产生失序问题，但是网络健壮性增强了</p><p><strong>虚电路和数据报服务的对比</strong></p><p> <img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806212312552.png" alt="image-20230806212312552"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806212321164.png" alt="image-20230806212321164"></p><h2 id="4-2-网际协议IP"><a href="#4-2-网际协议IP" class="headerlink" title="4.2 网际协议IP"></a>4.2 网际协议IP</h2><h3 id="4-2-1-虚拟互连网络"><a href="#4-2-1-虚拟互连网络" class="headerlink" title="4.2.1 虚拟互连网络"></a>4.2.1 虚拟互连网络</h3><h4 id="不同网络的差异"><a href="#不同网络的差异" class="headerlink" title="不同网络的差异"></a>不同网络的差异</h4><p><strong><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806212752293.png" alt="image-20230806212752293"></strong></p><p>通过使用中间设备来互连不同的网络—路由器（网络层）</p><h4 id="各种中间设备"><a href="#各种中间设备" class="headerlink" title="各种中间设备"></a>各种中间设备</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806213117006-1691328677767-1.png" alt="image-20230806213117006"></p><p>中继器和集线器是物理层设备</p><h4 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806213247881.png" alt="image-20230806213247881"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806213257734.png" alt="image-20230806213257734"></p><p>***IGMP？</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806213403935.png" alt="image-20230806213403935"></p><p>数据实际上运输会由上往下封装再由下往上解码运输，但是</p><h3 id="4-2-2-IP数据报的格式"><a href="#4-2-2-IP数据报的格式" class="headerlink" title="4.2.2 IP数据报的格式"></a>4.2.2 IP数据报的格式</h3><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806214222431.png" alt="image-20230806214222431"></p><p>IP数据报分为首部和数据两部分，其中首部分为固定部分20字节和可变部分</p><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>前4个字节是协议版本，例如IPv4</p><h4 id="首部长度"><a href="#首部长度" class="headerlink" title="首部长度"></a>首部长度</h4><p>一比特代表4字节</p><p>为1111时首部长15*4&#x3D;60字节</p><h4 id="区分服务"><a href="#区分服务" class="headerlink" title="区分服务"></a>区分服务</h4><p>一般不用</p><h4 id="总长度"><a href="#总长度" class="headerlink" title="总长度"></a>总长度</h4><p>首部+数据的长度，一比特为一字节</p><p>最大为2的16次方-1字节，但是实际上传输不了这么多—MTU限制总长度，那么就要将数据分片传输</p><h4 id="标识位"><a href="#标识位" class="headerlink" title="标识位"></a>标识位</h4><p>为了将分片的数据能够准确无误的重组</p><p><strong>所有分片都有相同的标识</strong></p><h4 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h4><p>为了将分片的数据能够准确无误的重组</p><p><strong>标志位中有保留位，待开发</strong></p><p>MF位：more fragment（是否最后分片），1表示后面还有分片，反之没有</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806220909198.png" alt="image-20230806220909198"></p><p>DF位：don‘t fragment（是否允许分片），1表示没有分片，0表示分片</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806220920117.png" alt="image-20230806220920117"></p><h4 id="片偏移"><a href="#片偏移" class="headerlink" title="片偏移"></a>片偏移</h4><p>为了将分片的数据能够准确无误的重组</p><p><strong>判断给数据开🔪的地方在哪里</strong></p><p><strong><u>栗子</u>：</strong></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806220507327.png" alt="image-20230806220507327"></p><p>每个MTU里面包括20字节的首部和1480字节的数据，增加了首部开销</p><p>问题：为什么不把分组平均</p><p>答：避免头重脚轻，浪费首部</p><h5 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806221237407.png" alt="image-20230806221237407"></p><p>数据的尾巴除以8得到偏移量 </p><h4 id="生存时间"><a href="#生存时间" class="headerlink" title="生存时间"></a>生存时间</h4><p>路由器之间传递一次叫<strong>跳</strong></p><p>生存时间就是规定这个跳的次数</p><p>不同的操作系统这个TTL（生存时间）值不同</p><p><em><strong><u>目的是不让数据在网络上无休止的浪费资源</u></strong></em></p><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>协议负责指出数据部分应该交给上层的哪个部分</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806222222105.png" alt="image-20230806222222105"></p><h4 id="首部校验和"><a href="#首部校验和" class="headerlink" title="首部校验和"></a>首部校验和</h4><p>只对首部的部分进行校验，首部变了校验和也发生变化，不用管数据部分，错了让运输层想办法</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806222448510.png" alt="image-20230806222448510"></p><h4 id="源地址，目的地址"><a href="#源地址，目的地址" class="headerlink" title="源地址，目的地址"></a>源地址，目的地址</h4><p>一个接口一个IP地址，32位的二进制地址</p><h4 id="可选字段"><a href="#可选字段" class="headerlink" title="可选字段"></a>可选字段</h4><p>不怎么用</p><h4 id="IP协议功能及报头字段总结"><a href="#IP协议功能及报头字段总结" class="headerlink" title="IP协议功能及报头字段总结"></a>IP协议功能及报头字段总结</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806223210166.png" alt="image-20230806223210166"></p><p>以上首部各部分功能</p><h2 id="4-2-3-IP地址"><a href="#4-2-3-IP地址" class="headerlink" title="4.2.3 IP地址"></a>4.2.3 IP地址</h2><p>IP是啥？你家的经纬度~</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806223603213.png" alt="image-20230806223603213"></p><p>32位还是少了</p><h5 id="IP地址采用2级结构"><a href="#IP地址采用2级结构" class="headerlink" title="IP地址采用2级结构"></a><strong>IP地址采用2级结构</strong></h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806224526292.png" alt="image-20230806224526292"></p><p>哪一个网络的哪一台主机？</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806224635807.png" alt="image-20230806224635807"></p><h5 id="分级地址优点"><a href="#分级地址优点" class="headerlink" title="分级地址优点"></a>分级地址优点</h5><p>方便分配和数据转发</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806224902585.png" alt="image-20230806224902585"></p><h5 id="点分十进制"><a href="#点分十进制" class="headerlink" title="点分十进制"></a>点分十进制</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806225032707.png" alt="image-20230806225032707"></p><p>一个字节一个部分</p><h4 id="分类的IP地址（old）"><a href="#分类的IP地址（old）" class="headerlink" title="分类的IP地址（old）"></a>分类的IP地址（old）</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806225250534.png" alt="image-20230806225250534"></p><p>类别判断：A类第一个比特是0，B类前两位是10，c类前三位是110；A类网络地址8位，B类16位，C类24位</p><h6 id="以A类地址为例"><a href="#以A类地址为例" class="headerlink" title="以A类地址为例"></a>以A类地址为例</h6><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806225710816.png" alt="image-20230806225710816"></p><p>网络地址除了标识符以外，全1表示用于本地软件环回测试，全0代表本网络（？）</p><p>主机地址全1表示该网络的所有主机（广播），全0代表主机所在的网络地址（84.0.0.0）</p><h6 id="网络大小"><a href="#网络大小" class="headerlink" title="网络大小"></a><strong>网络大小</strong></h6><p>这个网络大小差别太大，可能会取上不足取下有余，分配不灵活</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806230132160.png" alt="image-20230806230132160"></p><h6 id="不可分配地址"><a href="#不可分配地址" class="headerlink" title="不可分配地址"></a><strong>不可分配地址</strong></h6><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806230218512.png" alt="image-20230806230218512"></p><h4 id="子网划分（subnetting）"><a href="#子网划分（subnetting）" class="headerlink" title="子网划分（subnetting）"></a>子网划分（subnetting）</h4><p>就是使得划分标准增加以便合理调整网络大小<img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806230730738.png" alt="image-20230806230730738"></p><p>栗子：</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806230913588.png" alt="image-20230806230913588"></p><p>这样就能按照用户需求diy网络大小了</p><h6 id="子网掩码（可变VLSM？）"><a href="#子网掩码（可变VLSM？）" class="headerlink" title="子网掩码（可变VLSM？）"></a>子网掩码（可变VLSM？）</h6><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806231804265.png" alt="image-20230806231804265"></p><p>掩码用来计算网络地址</p><p>网络和子网位为1，主机位为0，再把掩码和IP地址AND一下后，仅保留网络地址（路由器要用）</p><h6 id="IP地址是否在同一个网络"><a href="#IP地址是否在同一个网络" class="headerlink" title="IP地址是否在同一个网络"></a>IP地址是否在同一个网络</h6><ul><li><p>子网掩码的位数相等</p></li><li><p>网络地址每一位都相同</p></li></ul><h6 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h6><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806232354376.png" alt="image-20230806232354376"></p><p><strong>解决了网络过大的问题，没有解决网络太小的问题</strong></p><h4 id="无分类编制方法CIDR（new）"><a href="#无分类编制方法CIDR（new）" class="headerlink" title="无分类编制方法CIDR（new）"></a>无分类编制方法CIDR（new）</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806232545705.png" alt="image-20230806232545705"></p><p><strong>网络前缀可以变长度</strong></p><h5 id="CIDR用掩码表示网络前缀的长度"><a href="#CIDR用掩码表示网络前缀的长度" class="headerlink" title="CIDR用掩码表示网络前缀的长度"></a>CIDR用掩码表示网络前缀的长度</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230806232941019.png" alt="image-20230806232941019"></p><h5 id="三个特殊地址块"><a href="#三个特殊地址块" class="headerlink" title="三个特殊地址块"></a>三个特殊地址块</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807000645119.png" alt="image-20230807000645119"></p><h5 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h5><ul><li><strong>构造超网</strong></li></ul><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807000813594.png" alt="image-20230807000813594"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807004212535.png" alt="image-20230807004212535"></p><p>分地址块就是把小数点往后面移动，构造超网就是左移（？ ）</p><ul><li><strong>减少路由条目</strong></li></ul><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807004706061.png" alt="image-20230807004706061"></p><p>地址数量也没有增加</p><h3 id="IP地址的特点"><a href="#IP地址的特点" class="headerlink" title="IP地址的特点"></a>IP地址的特点</h3><ul><li>每个IP地址都由网络前缀和主机号两部分组成<img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807005239784.png" alt="image-20230807005239784"></li><li>IP地址是标志一台主机（或路由器）和一条链路的接口</li></ul><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807005258395.png" alt="image-20230807005258395"></p><ul><li>转发器或交换机连起来的若干个局域网仍为一个网络<img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807005354436.png" alt="image-20230807005354436"></li><li>在IP地址中，所有分配到网络前缀的网络都是平等的</li></ul><h2 id="4-3-IP分组的转发"><a href="#4-3-IP分组的转发" class="headerlink" title="4.3 IP分组的转发"></a>4.3 IP分组的转发</h2><h3 id="路由器分组转发算法"><a href="#路由器分组转发算法" class="headerlink" title="路由器分组转发算法"></a>路由器分组转发算法</h3><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807111631247.png" alt="image-20230807111631247">255.255.255.255是广播地址但是发送这个的资源要求太大，一般情况下属于受限地址，只有直接地址可以转发</p><h3 id="4-3-1-基于终点的转发"><a href="#4-3-1-基于终点的转发" class="headerlink" title="4.3.1 基于终点的转发"></a>4.3.1 基于终点的转发</h3><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807101322460.png" alt="image-20230807101322460"></p><h6 id="路由器转发表包含哪些信息？"><a href="#路由器转发表包含哪些信息？" class="headerlink" title="路由器转发表包含哪些信息？"></a><strong>路由器转发表包含哪些信息？</strong></h6><ul><li>终点地址</li><li>下一跳地址</li></ul><p>*都是目的网络地址，为节约路由表空间</p><h6 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a><strong>栗子</strong></h6><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807103230926.png" alt="image-20230807103230926"></p><h6 id="转发步骤"><a href="#转发步骤" class="headerlink" title="转发步骤"></a>转发步骤</h6><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807103438419.png" alt="image-20230807103438419"></p><h6 id="问题：掩码从哪来？"><a href="#问题：掩码从哪来？" class="headerlink" title="问题：掩码从哪来？"></a>问题：掩码从哪来？</h6><p> IP首部不能更改，但是路由表还可以更改，在转发表地址加一个后缀即可，如128.0.0.12&#x2F;24</p><p>将目的地址和掩码AND后的网络号相同则转发，不同则跳过，比对下一条，全部不匹配则丢弃</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230808141625182.png" alt="image-20230808141625182"></p><h3 id="4-3-2-最长前缀匹配"><a href="#4-3-2-最长前缀匹配" class="headerlink" title="4.3.2 最长前缀匹配"></a>4.3.2 最长前缀匹配</h3><p>查找转发表的过程就是逐行寻找前缀匹配</p><p>使用CIDR时，<strong>查找转发表时可能会得到不同的匹配结果</strong>，子网掩码越大越精确(网络地址最长)</p><p>一般出现这种情况，网络有包含关系，例如学校的哪一个班</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807110520624.png" alt="image-20230807110520624"><strong>前缀最长的排更前面</strong></p><p><strong>特殊路由</strong></p><ul><li>主机路由a.b.c.d&#x2F;32—转发表最前面</li><li>默认路由0.0.0.0&#x2F;0—转发表最后面（兜底）</li></ul><h6 id="二叉线索查找"><a href="#二叉线索查找" class="headerlink" title="二叉线索查找"></a>二叉线索查找</h6><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807141640178.png" alt="image-20230807141640178"></p><h3 id="4-3-3-IP地址与MAC地址"><a href="#4-3-3-IP地址与MAC地址" class="headerlink" title="4.3.3 IP地址与MAC地址"></a>4.3.3 IP地址与MAC地址</h3><p>网络层已经有了IP地址，那么MAC地址还有用吗？</p><p><strong>上层的工作要依靠下层的服务</strong></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807141846232.png" alt="image-20230807141846232"></p><h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807142034635.png" alt="image-20230807142034635"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230808141221807.png" alt="image-20230808141221807"></p><p>那么怎么知道下一个路由器的MAC地址是多少呢？（由IP得到MAC地址–ARP协议）</p><h3 id="4-3-4-地址解析协议ARP"><a href="#4-3-4-地址解析协议ARP" class="headerlink" title="4.3.4 地址解析协议ARP"></a>4.3.4 地址解析协议ARP</h3><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807142659965.png" alt="image-20230807142659965"></p><p>广播ARP请求</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807142749072.png" alt="image-20230807142749072">单播ARP响应</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807143004913.png" alt="image-20230807143004913"><strong>流程图</strong></p><h4 id="ARP高速缓存"><a href="#ARP高速缓存" class="headerlink" title="ARP高速缓存"></a>ARP高速缓存</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807143045605.png" alt="image-20230807143045605"></p><p><strong>作用</strong></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807143137784.png" alt="image-20230807143137784"></p><p>减少广播通信，节约资源</p><p><u>2台主机在不同的局域网地址ARP时通过路由器来代传输，首先路由器当接收者回应ARP，然后又当发送者发送ARP请求，简称又当爹当妈</u></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807143744911.png" alt="image-20230807143744911"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807143753000.png" alt="image-20230807143753000"></p><h4 id="使用ARP的4种情况"><a href="#使用ARP的4种情况" class="headerlink" title="使用ARP的4种情况"></a>使用ARP的4种情况</h4><ul><li>同一局域网的不同主机</li></ul><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807143953144.png" alt="image-20230807143953144"></p><ul><li>不同局域网的不同主机</li></ul><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807144030029.png" alt="image-20230807144030029"></p><ul><li>路由器和主机（近）</li></ul><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807144218044.png" alt="image-20230807144218044"></p><ul><li>路由器和主机（远）</li></ul><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807144251058.png" alt="image-20230807144251058"></p><h4 id="使用IP的原因"><a href="#使用IP的原因" class="headerlink" title="使用IP的原因"></a>使用IP的原因</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807144456071.png" alt="image-20230807144456071"></p><h2 id="4-4-网络控制报文协议ICMP"><a href="#4-4-网络控制报文协议ICMP" class="headerlink" title="4.4 网络控制报文协议ICMP"></a>4.4 网络控制报文协议ICMP</h2><p><u>确保一定的准确性措施</u></p><h3 id="4-4-1-4-4-2-ICMP报文的格式和种类-ICMP的实际运用"><a href="#4-4-1-4-4-2-ICMP报文的格式和种类-ICMP的实际运用" class="headerlink" title="4.4.1|4.4.2 ICMP报文的格式和种类|ICMP的实际运用"></a>4.4.1|4.4.2 ICMP报文的格式和种类|ICMP的实际运用</h3><ul><li>允许主机或者路由器报告差错情况和提供有关异常情况的报告</li><li>由主机和路由器用于网络层的 通信</li><li>是网络层的协议</li></ul><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807151542329.png" alt="image-20230807151542329"></p><h4 id="报文种类"><a href="#报文种类" class="headerlink" title="报文种类"></a>报文种类</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807151607124.png" alt="image-20230807151607124"></p><p>某个问题的细节原因</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807151758185.png" alt="image-20230807151758185"></p><p>差错单向，<strong>询问双向</strong></p><h4 id="ICMP差错报文"><a href="#ICMP差错报文" class="headerlink" title="ICMP差错报文"></a>ICMP差错报文</h4><p>在数据丢失的时候产生报文</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807152032143.png" alt="image-20230807152032143"></p><h4 id="Traceroute-x2F-Tracert（追踪路由）"><a href="#Traceroute-x2F-Tracert（追踪路由）" class="headerlink" title="Traceroute&#x2F;Tracert（追踪路由）"></a>Traceroute&#x2F;Tracert（追踪路由）</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807152201649.png" alt="image-20230807152201649"></p><p><strong>方法</strong></p><p> <img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807152424539.png" alt="image-20230807152424539"></p><ul><li>源故意发错误信息</li><li>路由器丢弃</li><li>产生ICMP错误报文</li><li>回应，报文暴露路由器IP地址</li></ul><p>但是现在一些重要的路由器IP地址会收到保护无法使用Tracert</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230808141723742.png" alt="image-20230808141723742"></p><h4 id="不发ICMP的情况"><a href="#不发ICMP的情况" class="headerlink" title="不发ICMP的情况"></a>不发ICMP的情况</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807152745857-1691393271150-1.png" alt="image-20230807152745857"></p><ul><li>ICMP自己错误</li><li>第一个分片错了以后都不发（肯定错）</li><li>多播不发</li><li>特殊地址不发</li></ul><h4 id="ICMP询问报文"><a href="#ICMP询问报文" class="headerlink" title="ICMP询问报文"></a>ICMP询问报文</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807153029924.png" alt="image-20230807153029924"></p><h4 id="PING和ICMP"><a href="#PING和ICMP" class="headerlink" title="PING和ICMP"></a>PING和ICMP</h4><ul><li>用于测试两个主机之间的连通性</li><li>使用了ICMP的回送请求与会送回答报文</li></ul><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807153321359.png" alt="image-20230807153321359"></p><ul><li><strong>疯狂PING一个主机可以把它的资源占用完–DDoS</strong></li></ul><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230808141704500.png" alt="image-20230808141704500"></p><ul><li>可以通过返回的TTL<strong>值判断对方的操作系统</strong></li></ul><h2 id="4-5-IPv6"><a href="#4-5-IPv6" class="headerlink" title="4.5 IPv6"></a>4.5 IPv6</h2><h3 id="4-5-1-IPv6协议概述"><a href="#4-5-1-IPv6协议概述" class="headerlink" title="4.5.1 IPv6协议概述"></a>4.5.1 IPv6协议概述</h3><h4 id="出现原因："><a href="#出现原因：" class="headerlink" title="出现原因："></a>出现原因：</h4><ul><li><p>地址不足</p></li><li><p>分类不合理</p></li><li><p>NAT没有完美解决大小问题</p></li><li><p>安全问题</p></li><li><p>移动性支持弱</p></li></ul><h4 id="主要变化"><a href="#主要变化" class="headerlink" title="主要变化"></a>主要变化</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807154601034.png" alt="image-20230807154601034"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807154703967.png" alt="image-20230807154703967"></p><p>看看得了，记不住</p><h4 id="IP数据报的一般形式"><a href="#IP数据报的一般形式" class="headerlink" title="IP数据报的一般形式"></a>IP数据报的一般形式</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807154809377.png" alt="image-20230807154809377"></p><p>基本首部+有效载荷（扩展首部加数据部分）</p><h5 id="基本首部"><a href="#基本首部" class="headerlink" title="基本首部"></a>基本首部</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807154925383.png" alt="image-20230807154925383"></p><h6 id="版本-1"><a href="#版本-1" class="headerlink" title="版本"></a>版本</h6><p>指明协议版本–4位（0110&#x3D;6）</p><h6 id="通信量类"><a href="#通信量类" class="headerlink" title="通信量类"></a>通信量类</h6><p>8位，区分不同类别IPv6数据报或者优先级</p><h6 id="流标号"><a href="#流标号" class="headerlink" title="流标号"></a>流标号</h6><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807155217831.png" alt="image-20230807155217831">感觉有伏笔</p><h6 id="有效载荷长度"><a href="#有效载荷长度" class="headerlink" title="有效载荷长度"></a>有效载荷长度</h6><p>16位，指明有效载荷的字节数（除去基本首部）</p><h6 id="下一个首部"><a href="#下一个首部" class="headerlink" title="下一个首部"></a>下一个首部</h6><p>告知上层该数据之后要交给哪一个协议进行处理</p><h6 id="跳数限制"><a href="#跳数限制" class="headerlink" title="跳数限制"></a>跳数限制</h6><p>类似TTL</p><h5 id="IPv4和IPv6报文对比"><a href="#IPv4和IPv6报文对比" class="headerlink" title="IPv4和IPv6报文对比"></a>IPv4和IPv6报文对比</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807155730602.png" alt="image-20230807155730602"></p><h5 id="扩展首部"><a href="#扩展首部" class="headerlink" title="扩展首部"></a>扩展首部</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807155924524-1691395165160-3.png" alt="image-20230807155924524"></p><h3 id="4-5-2-IPv6的地址"><a href="#4-5-2-IPv6的地址" class="headerlink" title="4.5.2 IPv6的地址"></a>4.5.2 IPv6的地址</h3><ul><li>地址占128位</li><li>三种基本类型：单播、多播、任播–找最近的（广播变任播）</li></ul><h4 id="冒泡十六进制"><a href="#冒泡十六进制" class="headerlink" title="冒泡十六进制"></a>冒泡十六进制</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807160309236.png" alt="image-20230807160309236"></p><p>16个比特转为4位16进制数</p><p><strong>零压缩：一连串的0化简为两个冒号</strong></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807160759262.png" alt="image-20230807160759262">这种情况只能简化较为长的一段0，只能压缩一次</p><h5 id="点分十进制后缀"><a href="#点分十进制后缀" class="headerlink" title="点分十进制后缀"></a>点分十进制后缀</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807161315016.png" alt="image-20230807161315016"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230808141811108.png" alt="image-20230808141811108"></p><h5 id="前缀的表示方法"><a href="#前缀的表示方法" class="headerlink" title="前缀的表示方法"></a>前缀的表示方法</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807161004686.png" alt="image-20230807161004686"></p><p>子网掩码没了</p><h5 id="分类（略）"><a href="#分类（略）" class="headerlink" title="分类（略）"></a>分类（略）</h5><h5 id="零压缩"><a href="#零压缩" class="headerlink" title="零压缩"></a>零压缩</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230808141849205.png" alt="image-20230808141849205"></p><h5 id="地址分配"><a href="#地址分配" class="headerlink" title="地址分配"></a>地址分配</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807161701344.png" alt="image-20230807161701344"></p><p>无地址自动配置就是网络前缀加上你的MAC地址</p><p>ND:邻居发现</p><p>RS：路由器请求报文</p><h3 id="4-5-3-从IPv4到IPv6"><a href="#4-5-3-从IPv4到IPv6" class="headerlink" title="4.5.3 从IPv4到IPv6"></a>4.5.3 从IPv4到IPv6</h3><p>太先进很难适应，现在还在过渡</p><ul><li><p>向后兼容：v6可以兼容v4</p></li><li><p>过渡策略：</p><h4 id="双协议栈"><a href="#双协议栈" class="headerlink" title="双协议栈"></a>双协议栈</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807162407784.png" alt="image-20230807162407784"><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230808142050720.png" alt="image-20230808142050720"></p><h4 id="2-隧道技术"><a href="#2-隧道技术" class="headerlink" title="2.隧道技术"></a>2.隧道技术</h4></li></ul><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807162520160.png" alt="image-20230807162520160"></p><p>给v6套了个皮变成v4了</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230808142120111.png" alt="image-20230808142120111"></p><h3 id="4-5-4ICMPv6"><a href="#4-5-4ICMPv6" class="headerlink" title="4.5.4ICMPv6"></a>4.5.4ICMPv6</h3><p>升级版！ARP没了</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807165514244.png" alt="image-20230807165514244"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807165554884.png" alt="image-20230807165554884"></p><p>ND：临站发现</p><p>MLD：多播听众交付</p><h2 id="4-6-路由选择协议"><a href="#4-6-路由选择协议" class="headerlink" title="4.6 路由选择协议"></a>4.6 路由选择协议</h2><p>路由器怎么智能选择线路进行数据传输？</p><h3 id="4-6-1-路由选择协议概述"><a href="#4-6-1-路由选择协议概述" class="headerlink" title="4.6.1 路由选择协议概述"></a>4.6.1 路由选择协议概述</h3><h4 id="策略分类"><a href="#策略分类" class="headerlink" title="策略分类"></a>策略分类</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807170106633.png" alt="image-20230807170106633"></p><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807170254095.png" alt="image-20230807170254095"></p><p><strong>采用层次路由</strong></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807170345001.png" alt="image-20230807170345001"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807171111130.png" alt="image-20230807171111130"></p><h4 id="自治系统"><a href="#自治系统" class="headerlink" title="自治系统"></a>自治系统</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807170431409.png" alt="image-20230807170431409"></p><p>每一个AS<strong>区域使用单一和一致的路由选择策略</strong></p><p>接下来就介绍这些AS内策略，称为内部网关路由协议（IGP）</p><p>》》》》OSPF，RIP，IS-IS，IGPR，EIGRP</p><p>不同AS之间靠<u>BGP协议</u></p><h3 id="4-6-2内部网关协议RIP"><a href="#4-6-2内部网关协议RIP" class="headerlink" title="4.6.2内部网关协议RIP"></a>4.6.2内部网关协议RIP</h3><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807171135311.png" alt="image-20230807171135311"></p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807171208954.png" alt="image-20230807171208954"></p><ul><li>简单</li><li>基于经过路由器的数量</li><li>距离就是跳数</li><li><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807171337327.png" alt="image-20230807171337327"></li></ul><p>16这个数字在RIP中意为不可达</p><h4 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h4><ul><li>仅和相邻路由器交换信息</li><li>交换路由表</li><li>按<strong>固定时间间隔</strong>交换信息</li></ul><h4 id="RIP路由表的建立"><a href="#RIP路由表的建立" class="headerlink" title="RIP路由表的建立"></a>RIP路由表的建立</h4><ul><li>每个路由器刚开始知道自己的邻居</li><li>接着再告诉自己的其他邻居</li><li>若干次后谁都知道有谁了</li><li>RIP路由表项：目的网络，距离，下一跳</li><li>！！下一跳不变的情况下无脑更新，下一跳不同比较跳数，更新选择跳数小的</li></ul><h4 id="RIP2"><a href="#RIP2" class="headerlink" title="RIP2"></a>RIP2</h4><p>待补充</p><h4 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h4><p>好消息传得快，坏消息传得慢</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807173546461.png" alt="image-20230807173546461"></p><h3 id="4-6-3内部网关协议OSPF"><a href="#4-6-3内部网关协议OSPF" class="headerlink" title="4.6.3内部网关协议OSPF"></a>4.6.3内部网关协议OSPF</h3><p> 基于速度来判断</p><h4 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807174609321.png" alt="image-20230807174609321"></p><p>适用于大网络，使用层次结构的区域划分，加快了收敛速度,减少了网络流量（分主干区域和普通区域）</p><h4 id="度量值"><a href="#度量值" class="headerlink" title="度量值"></a>度量值</h4><p>费用，<strong>带宽</strong>，时延，距离</p><h4 id="区域边界路由器ABR"><a href="#区域边界路由器ABR" class="headerlink" title="区域边界路由器ABR"></a>区域边界路由器ABR</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807175227842.png" alt="image-20230807175227842"></p><p>如图R7</p><h4 id="自治系统边界路由器ASBR"><a href="#自治系统边界路由器ASBR" class="headerlink" title="自治系统边界路由器ASBR"></a>自治系统边界路由器ASBR</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807175330310.png" alt="image-20230807175330310"></p><p>如图R6</p><h4 id="5种分组类型"><a href="#5种分组类型" class="headerlink" title="5种分组类型"></a>5种分组类型</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807175524218.png" alt="image-20230807175524218"></p><h4 id="OSPF分组"><a href="#OSPF分组" class="headerlink" title="OSPF分组"></a>OSPF分组</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807175549576.png" alt="image-20230807175549576">好复杂。。。</p><h4 id="可靠的洪泛法"><a href="#可靠的洪泛法" class="headerlink" title="可靠的洪泛法"></a>可靠的洪泛法</h4><p>待补充</p><h3 id="4-6-4外部网关协议BGP"><a href="#4-6-4外部网关协议BGP" class="headerlink" title="4.6.4外部网关协议BGP"></a>4.6.4外部网关协议BGP</h3><h4 id="特点-7"><a href="#特点-7" class="headerlink" title="特点"></a>特点</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807175850277.png" alt="image-20230807175850277"></p><p>BGP发言人（ASBR）</p><p>*感觉就像外交官，主管外国</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807180238722.png" alt="image-20230807180238722"></p><p>内部不能通过BGP分享信息</p><h4 id="BGP路由信息"><a href="#BGP路由信息" class="headerlink" title="BGP路由信息"></a>BGP路由信息</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807180705853.png" alt="image-20230807180705853"></p><h4 id="BGP路由选择顺序"><a href="#BGP路由选择顺序" class="headerlink" title="BGP路由选择顺序"></a>BGP路由选择顺序</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807180740690.png" alt="image-20230807180740690"></p><ul><li>不能兜圈子</li><li>AS-PATH中，不允许出现相同的AS号</li></ul><h3 id="4-6-5路由器工作原理"><a href="#4-6-5路由器工作原理" class="headerlink" title="4.6.5路由器工作原理"></a>4.6.5路由器工作原理</h3><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807181339505.png" alt="image-20230807181339505"></p><p>核心功能：控制层面（各种路由协议+转发表）+数据层面（传输IP数据报）</p><h4 id="数据层面"><a href="#数据层面" class="headerlink" title="数据层面"></a>数据层面</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807181613046.png" alt="image-20230807181613046"></p><h4 id="核心层面"><a href="#核心层面" class="headerlink" title="核心层面"></a>核心层面</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807181635738.png" alt="image-20230807181635738"></p><h4 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807181842439.png" alt="image-20230807181842439"></p><p>有点像交换机</p><h4 id="路由种类优先级"><a href="#路由种类优先级" class="headerlink" title="路由种类优先级"></a>路由种类优先级</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807182009045.png" alt="image-20230807182009045"></p><h4 id="IP报文转发过程"><a href="#IP报文转发过程" class="headerlink" title="IP报文转发过程"></a>IP报文转发过程</h4><ul><li>链路层解封，IP头部校验</li><li>获取报文目的IP地址</li><li>基于IP地址查转发表</li><li>查询失败，丢弃报文</li><li>查询成功–》获取转发出接口和下一跳IP，TTL减一，计算校验和，链路层封装发送</li></ul><h4 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807182454857.png" alt="image-20230807182454857"></p><h2 id="4-7-IP多播"><a href="#4-7-IP多播" class="headerlink" title="4.7 IP多播"></a>4.7 IP多播</h2><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807182649216.png" alt="image-20230807182649216"></p><p><strong>应用</strong></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807182725459.png" alt="image-20230807182725459"></p><p><strong>实现步骤</strong></p><ul><li>确定多播组成员</li></ul><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807182825052.png" alt="image-20230807182825052"></p><ul><li>多播路由</li></ul><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807182936016.png" alt="image-20230807182936016"></p><p>转发多播数据的三种方法</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807183421026.png" alt="image-20230807183421026"></p><h2 id="4-8-VPN和NAT"><a href="#4-8-VPN和NAT" class="headerlink" title="4.8 VPN和NAT"></a>4.8 VPN和NAT</h2><h4 id="4-8-1-VPN"><a href="#4-8-1-VPN" class="headerlink" title="4.8.1 VPN"></a>4.8.1 VPN</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807183641376.png" alt="image-20230807183641376"></p><h4 id="4-8-2-NAT"><a href="#4-8-2-NAT" class="headerlink" title="4.8.2 NAT"></a>4.8.2 NAT</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807183802714.png" alt="image-20230807183802714"></p><h5 id="NAPT"><a href="#NAPT" class="headerlink" title="NAPT"></a>NAPT</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807183840227.png" alt="image-20230807183840227"></p><p>为了让公有网络进入私有网络能够分辨给哪个主机（一定程度上保护了私有网络）</p><h5 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807184107243.png" alt="image-20230807184107243"></p><h2 id="4-9-MPLS-简化路由表"><a href="#4-9-MPLS-简化路由表" class="headerlink" title="4.9 MPLS(简化路由表)"></a>4.9 MPLS(简化路由表)</h2><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807184225019.png" alt="image-20230807184225019"></p><ul><li>打标签</li><li>在链路层硬件转发</li></ul><p><strong>格式</strong></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807184601827.png" alt="image-20230807184601827"></p><h2 id="4-10-软件定义网络SDN"><a href="#4-10-软件定义网络SDN" class="headerlink" title="4.10 软件定义网络SDN"></a>4.10 软件定义网络SDN</h2><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807184656953-1691405218125-5.png" alt="image-20230807184656953"></p><p>在路由器的控制层面工作，将每一个路由器各自计算路由升级成统一管理，路由器就只有查表转发了，效率增加了</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807184919702.png" alt="image-20230807184919702"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230807185050656.png" alt="image-20230807185050656"></p><p>openflow–数据层面：流表（匹配加动作）</p><h1 id="第五章-运输层"><a href="#第五章-运输层" class="headerlink" title="第五章 运输层"></a>第五章 运输层</h1><h2 id="5-1-运输层解决的问题"><a href="#5-1-运输层解决的问题" class="headerlink" title="5.1 运输层解决的问题"></a>5.1 运输层解决的问题</h2><h3 id="5-1-1-进程之间的通信"><a href="#5-1-1-进程之间的通信" class="headerlink" title="5.1.1 进程之间的通信"></a>5.1.1 进程之间的通信</h3><ul><li><p>主机间的通信，本质上是两台主机的应用进程之间的通信</p></li><li><p>不同协议使用同一个运输协议叫做复用，从同一协议传输信息到不同进程叫做分用</p></li></ul><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812152945343.png" alt="image-20230812152945343"></p><h3 id="运输层提供的服务"><a href="#运输层提供的服务" class="headerlink" title="运输层提供的服务"></a>运输层提供的服务</h3><ul><li><strong>进程到进程的数据传输</strong></li><li><strong>差错检测</strong></li><li><strong>流量控制和拥塞控制</strong></li></ul><h3 id="5-1-2-运输层的两个重要协议"><a href="#5-1-2-运输层的两个重要协议" class="headerlink" title="5.1.2 运输层的两个重要协议"></a>5.1.2 运输层的两个重要协议</h3><h4 id="可靠信道与不可靠信道"><a href="#可靠信道与不可靠信道" class="headerlink" title="可靠信道与不可靠信道"></a>可靠信道与不可靠信道</h4><p>TCP面向连接的全双工可靠信道</p><p>UDP使用无连接的不可靠信道</p><h4 id="协议传输数据单元（TPDU）"><a href="#协议传输数据单元（TPDU）" class="headerlink" title="协议传输数据单元（TPDU）"></a>协议传输数据单元（TPDU）</h4><p>TCP—-TCP报文段</p><p>UDP–UDP报文段或用户数据报</p><h4 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812153907764.png" alt="image-20230812153907764"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812153925210.png" alt="image-20230812153925210"></p><p>这张图很重要，他会问你哪些应用适用哪个协议 </p><h3 id="5-1-3-运输层的端口"><a href="#5-1-3-运输层的端口" class="headerlink" title="5.1.3 运输层的端口"></a>5.1.3 运输层的端口</h3><h4 id="复用和分用"><a href="#复用和分用" class="headerlink" title="复用和分用"></a>复用和分用</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812154208217.png" alt="image-20230812154208217"></p><h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><p>全称<strong>协议端口号</strong></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812154251939.png" alt="image-20230812154251939"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812154330272.png" alt="image-20230812154330272"></p><p>IP是不能重复的，端口是独立的，是可以重复的</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812154428483.png" alt="image-20230812154428483"></p><p>管理部门：IANA</p><ul><li>通信需要知道对方的IP地址和端口（套接字socket&#x3D;（IP地址：端口号），如192.0.0.1：80）</li><li>UDP套接字——&lt;IP地址，端口号&gt;</li><li>TCP套接字——&lt;源IP地址，目的地址，源端口号，目的端口号&gt;</li></ul><h2 id="5-2-用户数据报协议UDP-（单工不连接）"><a href="#5-2-用户数据报协议UDP-（单工不连接）" class="headerlink" title="5.2 用户数据报协议UDP （单工不连接）"></a>5.2 用户数据报协议UDP （单工不连接）</h2><h3 id="5-2-1-UDP概述"><a href="#5-2-1-UDP概述" class="headerlink" title="5.2.1 UDP概述"></a>5.2.1 UDP概述</h3><p>在IP数据报上增加了复用，分用和差错检验</p><h4 id="特点-8"><a href="#特点-8" class="headerlink" title="特点"></a>特点</h4><ol><li><p><strong>无连接</strong></p></li><li><p><strong>尽最大努力交付</strong></p></li><li><p><strong>面向报文（不拆分）</strong></p></li><li><p><strong>没有拥塞控制</strong></p></li><li><p><strong>支持一对一，一对多，多对一，多对多</strong></p></li><li><p><strong>首部8字节，开销小</strong></p></li></ol><h4 id="适用应用"><a href="#适用应用" class="headerlink" title="适用应用"></a>适用应用</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812155300614.png" alt="image-20230812155300614"></p><h3 id="5-2-2-UDP的首部"><a href="#5-2-2-UDP的首部" class="headerlink" title="5.2.2 UDP的首部"></a>5.2.2 UDP的首部</h3><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812155331566.png" alt="image-20230812155331566"></p><p><strong><u>计算检验和的时候临时将12字节的伪首部计算，计算完成后丢弃</u></strong></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812160908216.png" alt="image-20230812160908216"></p><h2 id="5-3-传输控制协议TCP概述（全双工面向连接）"><a href="#5-3-传输控制协议TCP概述（全双工面向连接）" class="headerlink" title="5.3 传输控制协议TCP概述（全双工面向连接）"></a>5.3 传输控制协议TCP概述（全双工面向连接）</h2><h3 id="5-3-1-TCP概述"><a href="#5-3-1-TCP概述" class="headerlink" title="5.3.1 TCP概述"></a>5.3.1 TCP概述</h3><ul><li>面向连接</li><li>提供可靠传输</li><li>支持一对一通信</li><li>全双工通信</li><li>面向字节流，不保留报文边界</li></ul><h3 id="各种面向连接"><a href="#各种面向连接" class="headerlink" title="各种面向连接"></a>各种面向连接</h3><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812155819063.png" alt="image-20230812155819063"></p><h3 id="5-3-2-TCP的首部"><a href="#5-3-2-TCP的首部" class="headerlink" title="5.3.2 TCP的首部"></a>5.3.2 TCP的首部</h3><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812155956746.png" alt="image-20230812155956746"></p><p>20**<u>字节固定首部</u>**</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">.</span> <span class="string">源端口和目的端口：各占</span> <span class="number">2</span> <span class="string">字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能通过端口实现。</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span><span class="string">.</span> <span class="string">序号：占</span> <span class="number">4</span> <span class="string">字节。TCP</span> <span class="string">连接中传送的数据流中的每一个字节都有一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span><span class="string">.</span> <span class="string">确认号：占</span> <span class="number">4</span> <span class="string">字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。</span></span><br><span class="line"></span><br><span class="line"><span class="string">若确认号</span> <span class="string">=</span> <span class="string">N，则表明：到序号</span> <span class="string">N</span> <span class="string">–</span> <span class="number">1</span> <span class="string">为止的所有数据都已正确收到。</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span><span class="string">.</span> <span class="string">数据偏移（即首部长度）：占</span> <span class="number">4</span> <span class="string">位，指出</span> <span class="string">TCP</span> <span class="string">报文段的数据起始处距离</span> <span class="string">TCP</span> <span class="string">报文段的起始处有多远。单位是</span> <span class="number">32</span> <span class="string">位字（以</span> <span class="number">4</span> <span class="string">字节为计算单位）</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span><span class="string">.</span> <span class="string">保留：占</span> <span class="number">6</span> <span class="string">位，保留为今后使用，但目前应置为</span> <span class="number">0</span><span class="string">。</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span><span class="string">.</span> <span class="string">紧急</span> <span class="string">URG：控制位。当</span> <span class="string">URG</span> <span class="string">=</span> <span class="number">1</span> <span class="string">时，表明紧急指针字段有效，告诉系统此报文段中有紧急数据，应尽快传送</span> <span class="string">(相当于高优先级的数据)。</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span><span class="string">.</span> <span class="string">确认</span> <span class="string">ACK：控制位。只有当</span> <span class="string">ACK</span> <span class="string">=1</span> <span class="string">时，确认号字段才有效。当</span> <span class="string">ACK</span> <span class="string">=0</span> <span class="string">时，确认号无效。</span></span><br><span class="line"></span><br><span class="line"><span class="number">8</span><span class="string">.</span> <span class="string">推送</span> <span class="string">PSH</span> <span class="string">(PuSH)</span> <span class="string">：控制位。接收</span> <span class="string">TCP</span> <span class="string">收到</span> <span class="string">PSH</span> <span class="string">=</span> <span class="number">1</span> <span class="string">的报文段后，就尽快（即“推送”向前）交付接收应用进程，而不再等到整个缓存都填满后再交付。</span></span><br><span class="line"></span><br><span class="line"><span class="number">9</span><span class="string">.</span> <span class="string">复位</span> <span class="string">RST</span> <span class="string">(ReSeT)</span> <span class="string">：控制位。当</span> <span class="string">RST=1</span> <span class="string">时，表明</span> <span class="string">TCP</span> <span class="string">连接中出现严重差错（如主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span><span class="string">.</span> <span class="string">同步</span> <span class="string">SYN</span> <span class="string">(SYNchronization)</span> <span class="string">：控制位。同步</span> <span class="string">SYN</span> <span class="string">=</span> <span class="number">1</span> <span class="string">表示这是一个连接请求或连接接受报文。当</span> <span class="string">SYN</span> <span class="string">=</span> <span class="number">1</span><span class="string">，ACK</span> <span class="string">=</span> <span class="number">0</span> <span class="string">时，表明这是一个连接请求报文段。当</span> <span class="string">SYN</span> <span class="string">=</span> <span class="number">1</span><span class="string">，ACK</span> <span class="string">=</span> <span class="number">1</span> <span class="string">时，表明这是一个连接接受报文段。</span></span><br><span class="line"></span><br><span class="line"><span class="number">11</span><span class="string">.</span> <span class="string">终止</span> <span class="string">FIN</span> <span class="string">(FINish)</span> <span class="string">：控制位。用来释放一个连接。FIN=1</span> <span class="string">表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。</span></span><br><span class="line"></span><br><span class="line"><span class="number">12</span><span class="string">.</span> <span class="string">窗口：占</span> <span class="number">2</span> <span class="string">字节。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。</span></span><br><span class="line"></span><br><span class="line"><span class="string">窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化。</span></span><br><span class="line"></span><br><span class="line"><span class="number">13</span><span class="string">.</span> <span class="string">检验和：占</span> <span class="number">2</span> <span class="string">字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在</span> <span class="string">TCP</span> <span class="string">报文段的前面加上</span> <span class="number">12</span> <span class="string">字节的伪首部。</span></span><br><span class="line"></span><br><span class="line"><span class="number">14</span><span class="string">.</span> <span class="string">紧急指针：占</span> <span class="number">2</span> <span class="string">字节。在</span> <span class="string">URG</span> <span class="string">=</span> <span class="number">1</span><span class="string">时，指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据），指出了紧急数据的末尾在报文段中的位置。</span></span><br><span class="line"></span><br><span class="line"><span class="number">15</span><span class="string">.</span> <span class="string">选项：长度可变，最长可达</span> <span class="number">40</span> <span class="string">字节。</span></span><br><span class="line"></span><br><span class="line"><span class="number">16</span><span class="string">.</span> <span class="string">填充：使整个</span> <span class="string">TCP</span> <span class="string">首部长度是</span> <span class="number">4</span> <span class="string">字节的整数倍。</span></span><br></pre></td></tr></table></figure><h3 id="发送序号和确认序号的含义"><a href="#发送序号和确认序号的含义" class="headerlink" title="发送序号和确认序号的含义"></a>发送序号和确认序号的含义</h3><p>发送序号：数据载荷中第一个字节在字节的序号</p><p>确认号：期望收到的下一个字节的序号 </p><h3 id="最大报文段MSS"><a href="#最大报文段MSS" class="headerlink" title="最大报文段MSS"></a>最大报文段MSS</h3><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812161113341.png" alt="image-20230812161113341"></p><ul><li>太小网络利用率低</li><li>太大分片的开销大</li></ul><h4 id><a href="#" class="headerlink" title></a></h4><h2 id="5-4-可靠传输的工作原理"><a href="#5-4-可靠传输的工作原理" class="headerlink" title="5.4 可靠传输的工作原理"></a>5.4 可靠传输的工作原理</h2><h3 id="5-4-1-停止等待协议"><a href="#5-4-1-停止等待协议" class="headerlink" title="5.4.1 停止等待协议"></a>5.4.1 停止等待协议</h3><ul><li>每发送完一个分组就停止发送，等待对方的确认</li><li>全双工工作方式下既是发送方又是接收方</li></ul><h4 id="无差错情况"><a href="#无差错情况" class="headerlink" title="无差错情况"></a>无差错情况</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812161740264.png" alt="image-20230812161740264"></p><h4 id="分组错误"><a href="#分组错误" class="headerlink" title="分组错误"></a>分组错误</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812161804355.png" alt="image-20230812161804355"></p><p>b接收到M1时检测出错误并且丢弃</p><h4 id="分组丢失"><a href="#分组丢失" class="headerlink" title="分组丢失"></a>分组丢失</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812161821756.png" alt="image-20230812161821756">M1在传输过程中就丢失了，b不知道也什么都不做</p><p><strong><u>解决方法</u></strong>–<strong>超时重传</strong></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812162110026.png" alt="image-20230812162110026"><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812162126132.png" alt="image-20230812162126132"><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812162932293.png" alt="image-20230812162932293"></p><p>如果确认信息也丢失了？</p><ul><li>确认丢失</li></ul><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812162408674.png" alt="image-20230812162408674"></p><p>丢弃第二次收到的分组，向a发送确认</p><ul><li>确认迟到</li></ul><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812162946549.png" alt="image-20230812162946549"></p><p>双方都只认第一次</p><p>b丢弃第二次收到的M1，并且重新发送确认信息，a丢弃第二次确认</p><h4 id="特点-9"><a href="#特点-9" class="headerlink" title="特点"></a>特点</h4><ul><li>停止等待</li><li>暂存，为了重传</li><li>编号</li><li>超时重传</li></ul><h4 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812163432742.png" alt="image-20230812163432742"></p><p><strong>解决方法</strong></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812163451290.png" alt="image-20230812163451290"><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812163519604.png" alt="image-20230812163519604"></p><h3 id="5-4-2-连续ARQ协议"><a href="#5-4-2-连续ARQ协议" class="headerlink" title="5.4.2 连续ARQ协议"></a>5.4.2 连续ARQ协议</h3><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812163929140.png" alt="image-20230812163929140"></p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812163959931.png" alt="image-20230812163959931"></p><h4 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a>累计确认</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812164129206.png" alt="image-20230812164129206"></p><ul><li>优点：容易实现，确认丢失也不需要重传</li><li>缺点：不能向发 送方反应出接收方已经正确收到的</li></ul><h4 id="Go-back-N"><a href="#Go-back-N" class="headerlink" title="Go-back-N"></a>Go-back-N</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812172657080-1691832419155-1.png" alt="image-20230812172657080"></p><h4 id="与停止等待的对比"><a href="#与停止等待的对比" class="headerlink" title="与停止等待的对比"></a>与停止等待的对比</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812172743718.png" alt="image-20230812172743718"></p><h2 id="5-5-TCP可靠运输的实现"><a href="#5-5-TCP可靠运输的实现" class="headerlink" title="5.5 TCP可靠运输的实现"></a>5.5 TCP可靠运输的实现</h2><h3 id="5-5-1-以字节为单位的滑动窗口"><a href="#5-5-1-以字节为单位的滑动窗口" class="headerlink" title="5.5.1 以字节为单位的滑动窗口"></a>5.5.1 以字节为单位的滑动窗口</h3><ul><li>发送方和接收方各维持一个发送窗口和接收窗口</li><li>发送方根据接收方给出的窗口值构建出自己的发送窗口</li><li>发送窗口里面的序号表示允许发送的序号</li><li>窗口只能往序号大的方向移动和扩张</li></ul><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812173419545-1691832859974-3.png" alt="image-20230812173419545"></p><p><strong><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812173740468.png" alt="image-20230812173740468"></strong></p><h4 id="窗口的滑动"><a href="#窗口的滑动" class="headerlink" title="窗口的滑动"></a>窗口的滑动</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812173845689.png" alt="image-20230812173845689"></p><p>确认号是还没有收到的数据，是期望接收到的数据的序号</p><p>发送方每收到一个接受确认，就将发送窗口向前滑动一个字节的位置  </p><h4 id="发送缓存"><a href="#发送缓存" class="headerlink" title="发送缓存"></a>发送缓存</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812175414815.png" alt="image-20230812175414815"></p><h4 id="接收缓存"><a href="#接收缓存" class="headerlink" title="接收缓存"></a>接收缓存</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812175613916.png" alt="image-20230812175613916"></p><h3 id="5-5-2-超时重传时间的选择"><a href="#5-5-2-超时重传时间的选择" class="headerlink" title="5.5.2 超时重传时间的选择"></a>5.5.2 超时重传时间的选择</h3><h4 id="加权平均往返时间RTTs"><a href="#加权平均往返时间RTTs" class="headerlink" title="加权平均往返时间RTTs"></a>加权平均往返时间RTTs</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812175755674.png" alt="image-20230812175755674"></p><h4 id="超时重传时间RTO"><a href="#超时重传时间RTO" class="headerlink" title="超时重传时间RTO"></a>超时重传时间RTO</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812175920696.png" alt="image-20230812175920696"></p><h4 id="RTT偏差的加权平均值"><a href="#RTT偏差的加权平均值" class="headerlink" title="RTT偏差的加权平均值"></a>RTT偏差的加权平均值</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812180008096.png" alt="image-20230812180008096"></p><h4 id="Karn算法"><a href="#Karn算法" class="headerlink" title="Karn算法"></a>Karn算法</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812180115248.png" alt="image-20230812180115248"></p><h5 id="修正版"><a href="#修正版" class="headerlink" title="修正版"></a>修正版</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812180141017.png" alt="image-20230812180141017"></p><h3 id="5-5-3-选择确认SACK"><a href="#5-5-3-选择确认SACK" class="headerlink" title="5.5.3 选择确认SACK"></a>5.5.3 选择确认SACK</h3><p>一段数据中中间部分数据未传输，怎么只传输这些数据呢？</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812180317612.png" alt="image-20230812180317612"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812180327548.png" alt="image-20230812180327548"></p><h2 id="5-6-TCP的流量控制"><a href="#5-6-TCP的流量控制" class="headerlink" title="5.6 TCP的流量控制"></a>5.6 TCP的流量控制</h2><h3 id="5-6-1-利用滑动窗口实现流量控制"><a href="#5-6-1-利用滑动窗口实现流量控制" class="headerlink" title="5.6.1 利用滑动窗口实现流量控制"></a>5.6.1 利用滑动窗口实现流量控制</h3><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812180818607.png" alt="image-20230812180818607"></p><p>按接收方的接受能力来决定发送方的发送能力</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/640.png" alt="图片"></p><h4 id="持续计时器"><a href="#持续计时器" class="headerlink" title="持续计时器"></a>持续计时器</h4><p>只要 TCP 连接的一方收到对方的零窗口通知，就启动该持续计时器。</p><p>若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带 1 字节的数据），对方在确认这个探测报文段时给出当前窗口值。</p><p>若窗口仍然是零，收到这个报文段的一方就重新设置持续计时器。</p><p>若窗口不是零，则死锁的僵局就可以打破了。</p><h3 id="5-6-2-TCP的传输效率"><a href="#5-6-2-TCP的传输效率" class="headerlink" title="5.6.2 TCP的传输效率"></a>5.6.2 TCP的传输效率</h3><ul><li>缓存中数据到达MSS长度就组装成一个TCP报文段发送出去</li><li>按发送方的应用进程要求发送</li><li>发送方的计时器时间到了将当前的缓存数据发送出去</li></ul><h4 id="糊涂窗口综合征"><a href="#糊涂窗口综合征" class="headerlink" title="糊涂窗口综合征"></a>糊涂窗口综合征</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812183202333.png" alt="image-20230812183202333"></p><h2 id="5-7-TCP的拥塞控制"><a href="#5-7-TCP的拥塞控制" class="headerlink" title="5.7 TCP的拥塞控制"></a>5.7 TCP的拥塞控制</h2><h3 id="5-7-1-拥塞控制的一般原理"><a href="#5-7-1-拥塞控制的一般原理" class="headerlink" title="5.7.1 拥塞控制的一般原理"></a>5.7.1 拥塞控制的一般原理</h3><p>拥塞原因：大量分组短时间进入网络，超过网络的处理能力</p><ol><li>节点缓存容量太小</li><li>链路容量不足</li><li>处理机处理速率太慢</li><li>拥塞本身会进一步加剧拥塞</li><li><strong>资源要求大于供给</strong></li></ol><h4 id="理论解决方法"><a href="#理论解决方法" class="headerlink" title="理论解决方法"></a>理论解决方法</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812183924857.png" alt="image-20230812183924857"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812183948388-1691836788840-7.png" alt="image-20230812183948388"></p><h3 id="5-7-2-TCP的拥塞控制方法"><a href="#5-7-2-TCP的拥塞控制方法" class="headerlink" title="5.7.2 TCP的拥塞控制方法"></a>5.7.2 TCP的拥塞控制方法</h3><p><strong><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812184138229.png" alt="image-20230812184138229"></strong></p><p>出现拥塞将窗口减少，没有拥塞加大窗口</p><p><strong>拥塞发生依据</strong></p><p>超时重传计时器超时</p><p>收到三个重复的确认</p><h4 id="4种拥塞控制算法"><a href="#4种拥塞控制算法" class="headerlink" title="4种拥塞控制算法"></a>4种拥塞控制算法</h4><ol><li><p><strong>慢开始</strong></p></li><li><p><strong>拥塞避免</strong></p></li><li><p><strong>快重传</strong></p></li><li><p><strong>快恢复</strong></p></li></ol><p>ssthresh是标准，是阈值，cwnd是变量</p><h5 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h5><ul><li><p>慢开始就是指数增长（2的n次方）</p></li><li><p>cwnd和门限值的关系：</p><p>（1）当 cwnd &lt; ssthresh 时，使用慢开始算法。（指数）</p><p>（2）当 cwnd &gt; ssthresh 时，停止使用慢开始算法，改用拥塞避免算法。（线性）</p><p>（3）当 cwnd &#x3D; ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。（线性）</p></li></ul><h5 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h5><p>这时候cwnd线性增加</p><p><strong>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（重传定时器超时）：</strong></p><p><strong>（1）ssthresh &#x3D; max (cwnd&#x2F;2，2)</strong></p><p>**（2）cwnd &#x3D;1</p><p>*不能完全避免拥塞，只能减轻</p><h5 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h5><p>1.目的：让发送方尽早知道发生了个别报文段的丢失。</p><p>2.发送方只要连续收到三个重复的确认，就立即进行重传（即“快重传”），这样就不会出现超时。</p><p>3.使用快重传可以使整个网络的吞吐量提高约 20%。</p><p>4.快重传算法要求接收方立即发送确认，即使收到了失序的报文段，也要立即发出对已收到的报文段的重复确认。</p><h5 id="收到三个确认后会立即进行快恢复！！！（和拥塞避免有一点点差别）"><a href="#收到三个确认后会立即进行快恢复！！！（和拥塞避免有一点点差别）" class="headerlink" title="收到三个确认后会立即进行快恢复！！！（和拥塞避免有一点点差别）"></a><strong>收到三个确认后会立即进行快恢复</strong>！！！（和拥塞避免有一点点差别）</h5><p>1.慢开始门限 ssthresh &#x3D; 当前拥塞窗口 cwnd &#x2F; 2 ；</p><p>2.乘法减小 MD (Multiplicative Decrease) 拥塞窗口。（？）</p><p> <strong>新拥塞窗口 cwnd &#x3D; 慢开始门限 ssthresh</strong> </p><p>3.执行拥塞避免算法，使拥塞窗口缓慢地线性增大（加法增大 AI）。</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/640-1691842192980-9.png" alt="图片"></p><h2 id="-1"><a href="#-1" class="headerlink" title></a><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/640.png" alt="图片"></h2><h2 id="5-8-TCP的运输连接管理"><a href="#5-8-TCP的运输连接管理" class="headerlink" title="5.8 TCP的运输连接管理"></a>5.8 TCP的运输连接管理</h2><h3 id="5-8-1-TCP的连接建立"><a href="#5-8-1-TCP的连接建立" class="headerlink" title="5.8.1 TCP的连接建立"></a>5.8.1 TCP的连接建立</h3><p><strong>采用三报文握手：</strong>在客户和服务器之间交换三个 TCP 报文段，以防止已失效的连接请求报文段突然又传送到了服务器，因而产生TCP连接建立错误。</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/640-1691842456653-12.png" alt="图片"></p><h3 id="5-8-2-TCP的连接释放"><a href="#5-8-2-TCP的连接释放" class="headerlink" title="5.8.2 TCP的连接释放"></a>5.8.2 TCP的连接释放</h3><p>数据传输结束后，通信的双方都可释放连接。</p><p>TCP 连接释放过程是<strong>四报文挥手</strong>。</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/640-1691842471842-15.png" alt="图片">等待2MSL的时间的原因：</p><ol><li>保证发送的最后一个ACK报文段能够到达B</li><li>防止以失效的请求报文段出现在连接中（？）</li></ol><p><strong>保活计时器：</strong>防止在TCP连接中出现长时间空闲</p><h1 id="第六章-应用层"><a href="#第六章-应用层" class="headerlink" title="第六章 应用层"></a>第六章 应用层</h1><h2 id="6-1-域名系统DNS"><a href="#6-1-域名系统DNS" class="headerlink" title="6.1 域名系统DNS"></a>6.1 域名系统DNS</h2><h3 id="6-1-1域名系统概述"><a href="#6-1-1域名系统概述" class="headerlink" title="6.1.1域名系统概述"></a>6.1.1域名系统概述</h3><ol><li><p>域名系统 DNS用来把人们使用的机器名字（域名）转换为 IP 地址。</p></li><li><p>域名采用层次树状结构的命名方法</p></li><li><p>DNS 是一个联机分布式数据库系统，采用客户服务器方式。</p></li><li><p>域名到 IP 地址的解析是由若干个域名服务器程序共同完成。</p></li><li><p>域名服务器程序在专设的结点上运行，运行该程序的机器称为域名服务器</p></li></ol><h3 id="6-1-2-互联网的域名系统"><a href="#6-1-2-互联网的域名系统" class="headerlink" title="6.1.2 互联网的域名系统"></a>6.1.2 互联网的域名系统</h3><ol><li><p>命名方法：层次树状结构方法。</p></li><li><p>任何一个连接在互联网上的主机或路由器，都有一个唯一的层次结构的名字，即域名</p></li><li><p><strong>域 (domain)：</strong></p></li></ol><p>（1）名字空间中一个可被管理的划分。</p><p>（2）可以划分为子域，而子域还可继续划分为子域的子域，这样就形成了<strong>顶级域、二级域、三级域</strong>，等等。</p><ol start="4"><li><strong>域名结构：</strong>层次结构。由标号序列组成，各标号之间用点（.）隔开，各标号分别代表不同级别的域名</li></ol><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/640-1691844012684-18.png" alt="图片"></p><h3 id="6-1-3-域名服务器"><a href="#6-1-3-域名服务器" class="headerlink" title="6.1.3 域名服务器"></a>6.1.3 域名服务器</h3><h4 id="区的不同划分"><a href="#区的不同划分" class="headerlink" title="区的不同划分"></a>区的不同划分</h4><p>区等于域，区小于域</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812204224682.png" alt="image-20230812204224682"></p><h4 id="树状结构的域名服务器"><a href="#树状结构的域名服务器" class="headerlink" title="树状结构的域名服务器"></a>树状结构的域名服务器</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812204259630.png" alt="image-20230812204259630"></p><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812204320673.png" alt="image-20230812204320673"></p><h4 id="域名的解析过程"><a href="#域名的解析过程" class="headerlink" title="域名的解析过程"></a>域名的解析过程</h4><p>靠自己&#x2F;靠别人</p><h5 id="递归查询（靠别人）"><a href="#递归查询（靠别人）" class="headerlink" title="递归查询（靠别人）"></a>递归查询（靠别人）</h5><p>通常，主机向本地域名服务器查询时使用，若不知道，就以 DNS 客户的身份，向其他根域名服务器继续发出查询请求报文。</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/640-1691844285446-21.png" alt="图片"></p><h5 id="迭代查询（靠自己）"><a href="#迭代查询（靠自己）" class="headerlink" title="迭代查询（靠自己）"></a>迭代查询（靠自己）</h5><p>本地域名服务器向根域名服务器查询时使用，要么给出所要查询的 IP 地址，要么告诉下一个要查询的域名服务器的 IP 地址，本地域名服务器继续后续查询</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/640-1691844309746-24.png" alt="图片"></p><h4 id="高速缓存域名服务器"><a href="#高速缓存域名服务器" class="headerlink" title="高速缓存域名服务器"></a>高速缓存域名服务器</h4><p>存放最近用过的名字以及从何处获得名字映射信息的记录。</p><p>作用：大大减轻根域名服务器的负荷，使 DNS 查询请求和回答报文的数量大为减少。</p><h2 id="6-2-文件传送协议FTP"><a href="#6-2-文件传送协议FTP" class="headerlink" title="6.2 文件传送协议FTP"></a>6.2 文件传送协议FTP</h2><p><strong>使用了TCP</strong></p><h3 id="6-2-1-FTP概述"><a href="#6-2-1-FTP概述" class="headerlink" title="6.2.1 FTP概述"></a>6.2.1 FTP概述</h3><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812204746175.png" alt="image-20230812204746175"></p><h4 id="特点-10"><a href="#特点-10" class="headerlink" title="特点"></a>特点</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812204817385.png" alt="image-20230812204817385"><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812204827665.png" alt="image-20230812204827665"></p><h4 id="主进程工作步骤"><a href="#主进程工作步骤" class="headerlink" title="主进程工作步骤"></a>主进程工作步骤</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812205039858.png" alt="image-20230812205039858"></p><h4 id="6-2-3-简单文件传送协议TFTP"><a href="#6-2-3-简单文件传送协议TFTP" class="headerlink" title="6.2.3 简单文件传送协议TFTP"></a>6.2.3 简单文件传送协议TFTP</h4><p><strong>概述</strong></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812205255268.png" alt="image-20230812205255268"><strong>特点</strong></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812205324981.png" alt="image-20230812205324981"></p><h2 id="6-3-远程终端协议TELNET"><a href="#6-3-远程终端协议TELNET" class="headerlink" title="6.3 远程终端协议TELNET"></a>6.3 远程终端协议TELNET</h2><p>使用TCP</p><p><strong>概述</strong></p><p><strong><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812205408164.png" alt="image-20230812205408164"></strong></p><p><strong>TELNET使用网络虚拟终端NVT格式</strong></p><h2 id="6-4-万维网www"><a href="#6-4-万维网www" class="headerlink" title="6.4 万维网www"></a>6.4 万维网www</h2><h3 id="6-4-1-万维网概述"><a href="#6-4-1-万维网概述" class="headerlink" title="6.4.1 万维网概述"></a>6.4.1 万维网概述</h3><ol><li><p>万维网 WWW (World Wide Web) 是一个大规模的、联机式的信息储藏所，并非某种特殊的计算机网络</p></li><li><p>访问方法：链接</p></li><li><p>提供分布式服务</p></li><li><p>万维网的工作方式：客户服务器方式</p></li></ol><h3 id="6-4-2-统一资源定位符URL"><a href="#6-4-2-统一资源定位符URL" class="headerlink" title="6.4.2 统一资源定位符URL"></a>6.4.2 统一资源定位符URL</h3><p><strong>URL 的格式：</strong>由以冒号（:）隔开的两大部分组成，对字符大写或小写没有要求</p><p>一般形式：<img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/640-1691845110901-27.png" alt="图片"></p><h3 id="6-4-3-超文本传送协议http"><a href="#6-4-3-超文本传送协议http" class="headerlink" title="6.4.3 超文本传送协议http"></a>6.4.3 超文本传送协议http</h3><p>HTTP 使用了面向连接的 TCP 作为运输层协议，保证了数据的可靠传输。</p><p>HTTP 协议本身是无连接的。</p><p><strong>代理服务器（万维网高速缓存）：</strong></p><p>它代表浏览器发出 HTTP 请求，使用高速缓存可减少访问互联网服务器的时延。</p><p><strong>类似于高速缓存域名服务器</strong></p><h3 id="6-4-4-万维网的文档"><a href="#6-4-4-万维网的文档" class="headerlink" title="6.4.4 万维网的文档"></a>6.4.4 万维网的文档</h3><p>在一个客户程序主窗口上显示出的万维网文档称为页面 (page)。</p><p>页面制作的标准语言：HTML。</p><p><strong>注：HTML 不是应用层的协议，它只是万维网浏览器使用的一种语言。</strong></p><p><strong>想起了配置博客的痛苦时光</strong></p><h3 id="6-4-5-万维网的信息检索系统"><a href="#6-4-5-万维网的信息检索系统" class="headerlink" title="6.4.5 万维网的信息检索系统"></a>6.4.5 万维网的信息检索系统</h3><p>在万维网中用来进行搜索的程序叫做搜索引擎，分为全文检索搜索和分类目录搜索。</p><h3 id="6-4-6-博客和微博"><a href="#6-4-6-博客和微博" class="headerlink" title="6.4.6 博客和微博"></a>6.4.6 博客和微博</h3><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812210104614.png" alt="image-20230812210104614"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812210133543.png" alt="image-20230812210133543"></p><h3 id="6-4-7-社交网络"><a href="#6-4-7-社交网络" class="headerlink" title="6.4.7 社交网络"></a>6.4.7 社交网络</h3><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812210147387.png" alt="image-20230812210147387"></p><p>栗子：osu</p><h2 id="6-5-电子邮件"><a href="#6-5-电子邮件" class="headerlink" title="6.5 电子邮件"></a>6.5 电子邮件</h2><p>电子邮件 (e-mail)：指使用电子设备交换的邮件及其方法。</p><p><strong>优点：</strong>使用方便，传递迅速，费用低廉，可以传送多种类型的信息（包括：文字信息，声音和图像等）</p><p><strong>电子邮件系统的组成：</strong></p><ol><li><p>用户代理（用户与电子邮件系统的接口，又被称为电子邮件客户端软件）</p></li><li><p>邮件服务器（发送和接收邮件，同时还要向发信人报告邮件传送的情况，又被称为邮件传输代理，按照客户服务器方式工作）</p></li><li><p>邮件发送和读取协议（简单邮件发送协议 SMTP：用于在用户代理向邮件服务器或邮件服务器之间发送邮件。邮局协议 POP3：用于用户代理从邮件服务器读取邮件）</p></li></ol><p><strong>发送和接收电子邮件的步骤：</strong></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/640-1691845352215-30.png" alt="图片"></p><h2 id="6-6-动态主机配置协议DHCP"><a href="#6-6-动态主机配置协议DHCP" class="headerlink" title="6.6 动态主机配置协议DHCP"></a>6.6 动态主机配置协议DHCP</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol><li><p>动态主机配置协议 DHCP提供了即插即用连网的机制，允许一台计算机加入网络和获取 IP 地址，而不用手工配置。</p></li><li><p>DHCP 使用客户服务器方式，采用请求&#x2F;应答方式工作</p></li><li><p>DHCP 基于 UDP 工作，DHCP 服务器运行在 67 号端口， DHCP客户运行在 68 号端口。</p></li></ol><h3 id="DHCP中继代理"><a href="#DHCP中继代理" class="headerlink" title="DHCP中继代理"></a>DHCP中继代理</h3><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/640-1691845812347-33.png" alt="图片"></p><p>DHCP 中继代理收到主机广播发送的发现报文后，就以单播方式向 DHCP 服务器转发此报文，并等待其回答，收到 DHCP 服务器回答的提供报文后，DHCP 中继代理再将其发回给主机。</p><ul><li>每个网络上不都需要DHCP服务器</li><li>每一个网络至少有一个DHCP中继代理，它配置了DHCP服务器的IP地址信息</li></ul><h3 id="DHCP协议的工作过程"><a href="#DHCP协议的工作过程" class="headerlink" title="DHCP协议的工作过程"></a>DHCP协议的工作过程</h3><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/640-1691845964843-36.png" alt="图片"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. DHCP 服务器被动打开 UDP 端口 67，等待客户端发来的报文。</span><br><span class="line"></span><br><span class="line">2. DHCP 客户从 UDP 端口 68 发送 DHCP 发现报文 DHCPDISCOVER。</span><br><span class="line"></span><br><span class="line">3. 凡收到 DHCP 发现报文的 DHCP 服务器都发出 DHCP 提供报文 DHCPOFFER，因此 DHCP 客户可能收到多个 DHCP 提供报文 。</span><br><span class="line"></span><br><span class="line">4. DHCP 客户从几个 DHCP 服务器中选择其中的一个，并向所选择的 DHCP 服务器发送 DHCP 请求报文 DHCPREQUEST。</span><br><span class="line"></span><br><span class="line">5. 被选择的 DHCP 服务器发送确认报文 DHCPACK，DHCP 客户可开始使用得到的临时 IP 地址了，进入已绑定状态。DHCP 客户现在要根据服务器提供的租用期 T 设置两个计时器 T1 和 T2，它们的超时时间分别是 0.5T 和 0.875T。当超时时间到时，就要请求更新租用期。</span><br><span class="line"></span><br><span class="line">6. 租用期过了一半（T1 时间到），DHCP 发送请求报文 DHCPREQUEST，要求更新租用期。</span><br><span class="line"></span><br><span class="line">7. DHCP 服务器若同意，则发回确认报文 DHCPACK。DHCP 客户得到了新的租用期，重新设置计时器。</span><br><span class="line"></span><br><span class="line">8. DHCP 服务器若不同意，则发回否认报 DHCPNACK。这时 DHCP 客户必须立即停止使用原来的 IP 地址，而必须重新申请 IP 地址（回到步骤2）。若 DHCP 服务器不响应步骤6的请求报文 DHCPREQUEST，则在租用期过了 87.5% 时 (T2 时间到)，DHCP 客户必须重新发送请求报文 DHCPREQUEST（重复步骤6），然后又继续后面的步骤。</span><br><span class="line"></span><br><span class="line">9. DHCP 客户可随时提前终止服务器所提供的租用期，这时只需向 DHCP 服务器发送释放报文 DHCPRELEASE 即可。</span><br></pre></td></tr></table></figure><h2 id="6-7-简单网络管理协议SNMP"><a href="#6-7-简单网络管理协议SNMP" class="headerlink" title="6.7 简单网络管理协议SNMP"></a>6.7 简单网络管理协议SNMP</h2><h3 id="6-7-1-网络管理的基本概念"><a href="#6-7-1-网络管理的基本概念" class="headerlink" title="6.7.1 网络管理的基本概念"></a>6.7.1 网络管理的基本概念</h3><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812212126877.png" alt="image-20230812212126877"></p><h4 id="被管对象"><a href="#被管对象" class="headerlink" title="被管对象"></a>被管对象</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812212213600.png" alt="image-20230812212213600"></p><h4 id="网络管理协议"><a href="#网络管理协议" class="headerlink" title="网络管理协议"></a>网络管理协议</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812212251871.png" alt="image-20230812212251871"></p><h3 id="6-7-2-管理信息结构SMI"><a href="#6-7-2-管理信息结构SMI" class="headerlink" title="6.7.2 管理信息结构SMI"></a>6.7.2 管理信息结构SMI</h3><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812212323067.png" alt="image-20230812212323067"></p><p><strong>功能</strong></p><ol><li>被管对象命名</li><li>储存被管对象的数据类型有哪些</li><li>管理数据怎么编码</li></ol><h3 id="6-7-3-管理信息库MIB（略）"><a href="#6-7-3-管理信息库MIB（略）" class="headerlink" title="6.7.3 管理信息库MIB（略）"></a>6.7.3 管理信息库MIB（略）</h3><h3 id="6-7-4-SNMP的协议数据单元和报文"><a href="#6-7-4-SNMP的协议数据单元和报文" class="headerlink" title="6.7.4 SNMP的协议数据单元和报文"></a>6.7.4 SNMP的协议数据单元和报文</h3><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812212513276.png" alt="image-20230812212513276"><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812212616304.png" alt="image-20230812212616304"></p><h4 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812212646703.png" alt="image-20230812212646703"></p><h4 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812212724355.png" alt="image-20230812212724355"></p><h2 id="6-8-应用进程跨越网络的通信"><a href="#6-8-应用进程跨越网络的通信" class="headerlink" title="6.8 应用进程跨越网络的通信"></a>6.8 应用进程跨越网络的通信</h2><h3 id="6-8-1-系统调用和应用编程接口"><a href="#6-8-1-系统调用和应用编程接口" class="headerlink" title="6.8.1 系统调用和应用编程接口"></a>6.8.1 系统调用和应用编程接口</h3><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812213014751.png" alt="image-20230812213014751"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812213004210.png" alt="image-20230812213004210"></p><h4 id="应用编程接口"><a href="#应用编程接口" class="headerlink" title="应用编程接口"></a>应用编程接口</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812212915430.png" alt="image-20230812212915430"></p><h5 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h5><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812212933833.png" alt="image-20230812212933833"></p><p><strong>应用进程通过套接字接入到网络</strong></p><h4 id="套接字作用"><a href="#套接字作用" class="headerlink" title="套接字作用"></a>套接字作用</h4><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812213156041.png" alt="image-20230812213156041"></p><h2 id="6-9-P2P应用"><a href="#6-9-P2P应用" class="headerlink" title="6.9 P2P应用"></a>6.9 P2P应用</h2><h3 id="6-9-1-具有集中目录服务器的P2P工作方式（Napster）"><a href="#6-9-1-具有集中目录服务器的P2P工作方式（Napster）" class="headerlink" title="6.9.1 具有集中目录服务器的P2P工作方式（Napster）"></a>6.9.1 具有集中目录服务器的P2P工作方式（Napster）</h3><p>最早的P2P技术</p><h3 id="6-9-2-具有全分布方式结构的P2P文件共享程序（eMule）"><a href="#6-9-2-具有全分布方式结构的P2P文件共享程序（eMule）" class="headerlink" title="6.9.2 具有全分布方式结构的P2P文件共享程序（eMule）"></a>6.9.2 具有全分布方式结构的P2P文件共享程序（eMule）</h3><p>使用分散定位和分散传输技术</p><h3 id="6-9-3-P2P文件分发的分析（略）"><a href="#6-9-3-P2P文件分发的分析（略）" class="headerlink" title="6.9.3 P2P文件分发的分析（略）"></a>6.9.3 P2P文件分发的分析（略）</h3><h1 id="第三次作业改正"><a href="#第三次作业改正" class="headerlink" title="第三次作业改正"></a>第三次作业改正</h1><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812215039154.png" alt="image-20230812215039154"></p><p>第一个报文丢失，b要求a重发这个报文段，而确认号就是b想要的报文段的序号</p><p>所以是100</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812215153679.png" alt="image-20230812215153679"></p><p>第一次1</p><p>第二次2</p><p>3–4</p><p>4–8</p><p>5–9</p><p>6–10</p><p>7–1（门限值变成4）</p><p>8–2</p><p>9–4</p><p>10–5</p><p>11–6</p><p>大小为6</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230812215358639.png" alt="image-20230812215358639"></p><p>贝多芬题</p><p><img src="/.io//image-20230812215432062.png" alt="image-20230812215432062"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一节：概述&quot;&gt;&lt;a href=&quot;#第一节：概述&quot; class=&quot;headerlink&quot; title=&quot;第一节：概述&quot;&gt;&lt;/a&gt;&lt;strong&gt;第一节：概述&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;1-1-计算机网络在信息时代的作用&quot;&gt;&lt;a href=&quot;#1-1</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://charles-webebr.github.io/2023/01/05/python%E5%AD%A6%E4%B9%A0/"/>
    <id>http://charles-webebr.github.io/2023/01/05/python%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-01-05T14:26:51.155Z</published>
    <updated>2023-09-26T11:51:54.943Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="python学习"><a href="#python学习" class="headerlink" title="python学习"></a>python学习</h1><p>入门：</p><p>level0：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure><p>level1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">List1=(<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line">i=<span class="number">0</span></span><br><span class="line">x1=<span class="number">0</span></span><br><span class="line">x2=<span class="number">0</span></span><br><span class="line">list2=[<span class="string">&quot;第一把&quot;</span>,<span class="string">&quot;第二把&quot;</span>,<span class="string">&quot;第三把&quot;</span>,<span class="string">&quot;第四把&quot;</span>,<span class="string">&quot;第五把&quot;</span>]</span><br><span class="line">list3=[<span class="string">&quot;玩家胜利&quot;</span>,<span class="string">&quot;电脑胜利&quot;</span>,<span class="string">&quot;平局&quot;</span>]</span><br><span class="line"><span class="keyword">while</span> i&lt;<span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(list2[i])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请出拳&quot;</span>)</span><br><span class="line">    a=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;&#x27;0&#x27;代表拳头&#x27;2&#x27;代表剪刀&#x27;5&#x27;代表布\n&quot;</span>))</span><br><span class="line">    b=random.choice(List1)</span><br><span class="line">    <span class="keyword">if</span> a==b:</span><br><span class="line">        <span class="built_in">print</span>(list3[<span class="number">2</span>])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;本局重新开始&quot;</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">elif</span> a==<span class="number">0</span> <span class="keyword">and</span> b==<span class="number">2</span>:</span><br><span class="line">        <span class="built_in">print</span>(list3[<span class="number">0</span>])</span><br><span class="line">        x1+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> a==<span class="number">0</span> <span class="keyword">and</span> b==<span class="number">5</span>:</span><br><span class="line">        <span class="built_in">print</span>(list3[<span class="number">1</span>])</span><br><span class="line">        x2+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> a==<span class="number">2</span> <span class="keyword">and</span> b==<span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(list3[<span class="number">1</span>])</span><br><span class="line">        x2+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> a==<span class="number">2</span> <span class="keyword">and</span> b==<span class="number">5</span>:</span><br><span class="line">        <span class="built_in">print</span>(list3[<span class="number">0</span>])</span><br><span class="line">        x1+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> a==<span class="number">5</span> <span class="keyword">and</span> b==<span class="number">2</span>:</span><br><span class="line">        <span class="built_in">print</span>(list3[<span class="number">1</span>])</span><br><span class="line">        x2+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(list3[<span class="number">0</span>])</span><br><span class="line">        x1+=<span class="number">1</span></span><br><span class="line">    i+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> x1==<span class="number">3</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;玩家获得了游戏的胜利&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> x2==<span class="number">3</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;电脑获得了游戏的胜利&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span>   </span><br><span class="line"> </span><br><span class="line"><span class="built_in">input</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230105223544426.png" alt="image-20230105223544426"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230105223559679.png" alt="image-20230105223559679"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;python学习&quot;&gt;&lt;a href=&quot;#python学习&quot; class=&quot;headerlink&quot; title=&quot;python学习&quot;&gt;&lt;/a&gt;python学习&lt;/h1&gt;&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://charles-webebr.github.io/2023/01/05/SRE/"/>
    <id>http://charles-webebr.github.io/2023/01/05/SRE/</id>
    <published>2023-01-05T09:23:33.269Z</published>
    <updated>2023-09-26T11:52:01.985Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="SRE："><a href="#SRE：" class="headerlink" title="SRE："></a>SRE：</h1><p>1.Linux中的一些简单的文件操作命令</p><p>特别关注：cd与ls</p><p>2.vim的使用</p><p>（cat加文件名会预览内容）</p><p>3.命令的共性：</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230107110921354.png" alt="image-20230107110921354"></p><p>-加命令参数的简称，–加全称</p><p>4.成功的man！</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230107111427521.png" alt="image-20230107111427521"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/mage-20230107111515231.png" alt="image-20230107111515231"></p><p>linux的文件系统：</p><p><img src="/.io//image-20230107112446048.png" alt="image-20230107112446048"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230107112804590.png" alt="image-20230107112804590"></p><p><img src="/.io//image-20230107113020655.png" alt="image-20230107113020655"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230107113624989.png" alt="image-20230107113624989"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230107114332756.png" alt="image-20230107114332756"></p><p><img src="/.io//image-20230107121357961.png" alt="image-20230107121357961"></p><p>python:</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230105202656929.png" alt="image-20230105202656929"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230105202739144.png" alt="image-20230105202739144"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230105202822621.png" alt="image-20230105202822621"></p><p><img src="/.io//image-20230105202850493.png" alt="image-20230105202850493"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230105202939278.png" alt="image-20230105202939278"></p><p>(直接交给你原来用c写的例题)</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230105203030623.png" alt="image-20230105203030623"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230105203050074.png" alt="image-20230105203050074"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230105203215989.png" alt="image-20230105203215989"></p><p><img src="/.io//image-20230105203414935.png" alt="image-20230105203414935"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230105203623236.png" alt="image-20230105203623236"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230105203643793.png" alt="image-20230105203643793"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230105203807153.png" alt="image-20230105203807153"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230105203949004.png" alt="image-20230105203949004"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/" alt="image-20230105204218145"></p><p><img src="/.io//image-20230105204642001.png" alt="image-20230105204642001"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230105204746297.png" alt="image-20230105204746297"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230105205020634.png" alt="image-20230105205020634"></p><p><img src="/.io//image-20230105205159295.png" alt="image-20230105205159295"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230105205625532.png" alt="image-20230105205625532"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230105210003164.png" alt="image-20230105210003164"></p><p>(有点像是c中调用自己的库函数)</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230105210301711.png" alt="image-20230105210301711"></p><p>（区别对待）</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230105210752949.png" alt="image-20230105210752949"></p><p>（开始懵逼了老铁）</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230105210909584.png" alt="image-20230105210909584"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;SRE：&quot;&gt;&lt;a href=&quot;#SRE：&quot; class=&quot;headerlink&quot; title=&quot;SRE：&quot;&gt;&lt;/a&gt;SRE：&lt;/h1&gt;&lt;p&gt;1.Linux中的一些简单的文件</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://charles-webebr.github.io/2022/12/10/%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89/"/>
    <id>http://charles-webebr.github.io/2022/12/10/%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89/</id>
    <published>2022-12-10T15:27:54.029Z</published>
    <updated>2023-09-26T11:52:40.659Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h1><p>栈（stack）又名堆栈，堆栈也是一种线性表，一种操作受限的线性表，只能在栈顶插入&#x2F;删除数据元素，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</p><h1 id="顺序栈的实现："><a href="#顺序栈的实现：" class="headerlink" title="顺序栈的实现："></a>顺序栈的实现：</h1><p><strong>堆栈的一些基本操作（地基）：</strong></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221210210150354.png" alt="image-20221210210150354"></p><h1 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a><strong>代码实现：</strong></h1><h2 id="1-栈的定义："><a href="#1-栈的定义：" class="headerlink" title="1.栈的定义："></a>1.栈的定义：</h2><p><img src="/.io//image-20221210232812197.png" alt="image-20221210232812197"></p><h2 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2.初始化"></a>2.初始化</h2><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221210232927062.png" alt="image-20221210232927062"></p><h2 id="3-判断空栈"><a href="#3-判断空栈" class="headerlink" title="3.判断空栈"></a>3.判断空栈</h2><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221210233016694.png" alt="image-20221210233016694"></p><h2 id="4-取栈顶元素"><a href="#4-取栈顶元素" class="headerlink" title="4.取栈顶元素"></a>4.取栈顶元素</h2><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221210233153804.png" alt="image-20221210233153804"></p><h2 id="5-存储元素"><a href="#5-存储元素" class="headerlink" title="5.存储元素"></a>5.存储元素</h2><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221210233410530.png" alt="image-20221210233410530"></p><h2 id="6-取出元素"><a href="#6-取出元素" class="headerlink" title="6.取出元素"></a>6.取出元素</h2><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221210233237464.png" alt="image-20221210233237464"></p><h2 id="7-求栈长度"><a href="#7-求栈长度" class="headerlink" title="7.求栈长度"></a>7.求栈长度</h2><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221210233508004.png" alt="image-20221210233508004"></p><h2 id="8-清空栈"><a href="#8-清空栈" class="headerlink" title="8.清空栈"></a>8.清空栈</h2><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221210233548995.png" alt="image-20221210233548995"></p><h1 id="栈的应用："><a href="#栈的应用：" class="headerlink" title="栈的应用："></a>栈的应用：</h1><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><strong>将A,B,C,D,E,F存入栈，再将E,F取出，存入G,H,并且每次输出栈顶中的所有元素，最后输出栈的长度，所有元素。</strong></p><p>结果：<img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221211012944405.png" alt="image-20221211012944405"></p><p>代码：</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221211011710074.png" alt="image-20221211011710074"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221211011746259.png" alt="image-20221211011746259"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221211011759376.png" alt="image-20221211011759376"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;栈的定义&quot;&gt;&lt;a href=&quot;#栈的定义&quot; class=&quot;headerlink&quot; title=&quot;栈的定义&quot;&gt;&lt;/a&gt;栈的定义&lt;/h1&gt;&lt;p&gt;栈（stack）又名堆栈，堆栈也</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>c for class</title>
    <link href="http://charles-webebr.github.io/2022/11/27/%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A%EF%BC%9A/"/>
    <id>http://charles-webebr.github.io/2022/11/27/%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A%EF%BC%9A/</id>
    <published>2022-11-27T06:42:02.000Z</published>
    <updated>2023-09-26T11:52:20.715Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><strong>预习作业</strong>：</p><h1 id="第一题："><a href="#第一题：" class="headerlink" title="第一题："></a>第一题：</h1><p>代码：<img src="/.io//image-20221127010623387.png" alt="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221127010623387"></p><p>结果：</p><p><img src="/.io//image-20221127010653511.png" alt="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221127010653511"></p><p><img src="/.io//image-20221127010731709.png" alt="image-20221127010731709"></p><h1 id="第二题："><a href="#第二题：" class="headerlink" title="第二题："></a>第二题：</h1><p><img src="/.io//image-20221127011042322.png" alt="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221127011042322"></p><p>成功写入：</p><p><img src="/.io//image-20221127011148325.png" alt="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221127011148325"></p><h1 id="第三题："><a href="#第三题：" class="headerlink" title="第三题："></a>第三题：</h1><p>代码：</p><p><img src="/.io//image-20221127011917598.png" alt="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221127011917598"></p><p>成功读取：</p><p><img src="/.io//image-20221127011839081.png" alt="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221127011839081"></p><h1 id="第四题："><a href="#第四题：" class="headerlink" title="第四题："></a>第四题：</h1><p>代码：</p><p>写入成功</p><p><img src="/.io//image-20221127111456038.png" alt="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221127111456038"></p><h1 id="第五题："><a href="#第五题：" class="headerlink" title="第五题："></a>第五题：</h1><p>代码：<img src="/.io//image-20221127112020973.png" alt="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221127112020973"></p><p>结果：</p><p><img src="/.io//image-20221127112152793.png" alt="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221127112152793"></p><h1 id="第六题："><a href="#第六题：" class="headerlink" title="第六题："></a>第六题：</h1><h2 id="1-结构体的概念："><a href="#1-结构体的概念：" class="headerlink" title="1.结构体的概念："></a>1.结构体的概念：</h2><p><img src="/.io//image-20221127113549763.png" alt="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221127113549763"></p><h2 id="2-结构体的定义："><a href="#2-结构体的定义：" class="headerlink" title="2.结构体的定义："></a>2.结构体的定义：</h2><p><img src="/.io//image-20221127114233449.png" alt="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221127114233449"></p><h2 id="3-结构体的使用："><a href="#3-结构体的使用：" class="headerlink" title="3.结构体的使用："></a>3.结构体的使用：</h2><h3 id="（1）变量的初始化："><a href="#（1）变量的初始化：" class="headerlink" title="（1）变量的初始化："></a>（1）变量的初始化：</h3><p>​</p><p><img src="/.io//image-20221127115447557.png" alt="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221127115447557"></p><p>​</p><h3 id="（2）结构体的输出（成员访问）："><a href="#（2）结构体的输出（成员访问）：" class="headerlink" title="（2）结构体的输出（成员访问）："></a>（2）结构体的输出（成员访问）：</h3><p>代码：<img src="/.io//image-20221127115429979.png" alt="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221127115429979"></p><p>结果：</p><p><img src="/.io//image-20221127115358502.png" alt="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221127115358502"></p><p><strong>注意：</strong></p><p><img src="/.io//image-20221127120018229.png" alt="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221127120018229"></p><h3 id="（3）结构体的赋值："><a href="#（3）结构体的赋值：" class="headerlink" title="（3）结构体的赋值："></a>（3）结构体的赋值：</h3><p>​代码：<img src="/.io//image-20221127121524532.png" alt="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221127121524532"></p><p>​结果：</p><p>​</p><p><img src="/.io//image-20221127121543275.png" alt="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221127121543275"></p><p>​                注意：字符串赋值使用errno_t strcat_s(<strong>char *_Dst</strong>, rsize_t _SizeInBytes, const char *_Src)函数，需要加入头文件——#include &lt;string.h&gt;</p><p>​疑问：如何让用户输入呢？</p><h4 id="（4）互相赋值：结构体变量可以相互赋值"><a href="#（4）互相赋值：结构体变量可以相互赋值" class="headerlink" title="（4）互相赋值：结构体变量可以相互赋值"></a>（4）互相赋值：结构体变量可以相互赋值</h4><p>​代码：</p><p><img src="/.io//image-20221127123120015.png" alt="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221127123120015"></p><p>结果：</p><p><img src="/.io//image-20221127123037598.png" alt="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221127123037598"></p><h1 id="4-数组结构体："><a href="#4-数组结构体：" class="headerlink" title="4.数组结构体："></a>4.数组结构体：</h1><p>可以理解成定义了n个同类型的结构体，他们没名字，有代号[n-1]</p><p>类比普通数组即可。</p><p>构造，输入，输出，赋值：</p><p><img src="/.io//image-20221127161316039.png" alt="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221127161316039"></p><p>结果：</p><p><img src="/.io//image-20221127161330307.png" alt="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221127161330307"></p><h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><p>一个示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">char</span> num[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OutputSTU</span><span class="params">(<span class="keyword">struct</span> STU stu[<span class="number">5</span>])</span>;  <span class="comment">//函数声明, 该函数的功能是输出学号最大的学生信息</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">STU</span> <span class="title">stu</span>[5];</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入第%d个学生的信息:&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%s%d %c%s&quot;</span>, stu[i].name, &amp;stu[i].age, &amp;stu[i].sex, stu[i].num);<span class="comment">/*%c前面要加空格, 不然输入时会将空格赋给%c*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    OutputSTU(stu);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OutputSTU</span><span class="params">(<span class="keyword">struct</span> STU stu[<span class="number">5</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">STU</span> <span class="title">stumax</span> =</span> stu[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;<span class="number">5</span>; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(stumax.num, stu[j].num) &lt; <span class="number">0</span>)  <span class="comment">//strcmp函数的使用</span></span><br><span class="line">        &#123;</span><br><span class="line">            stumax = stu[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;学生姓名：%s 学生年龄：%d 学生性别：%c 学生学号：%s\n&quot;</span>, stumax.name, stumax.age, stumax.sex, stumax.num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中的一个新函数：strcmp</p><p><img src="/.io//image-20221127161830350.png" alt="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221127161830350"></p><h1 id="最后一个：指针结构体"><a href="#最后一个：指针结构体" class="headerlink" title="最后一个：指针结构体"></a>最后一个：指针结构体</h1><p>首先要先打好结构体（node）的框架，再定义一个这种类型的结构体a，再定义一个这个结构体的指针变量，取走a的地址，就可以用指针来”替换“a（没开始学指针，只是初印象）</p><p>​代码：</p><p>定义，取地址，赋值，输入，输出：</p><p><img src="/.io//image-20221127165057737.png" alt="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221127165057737"></p><p>结果：<img src="/.io//image-20221127165120965.png" alt="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221127165120965"></p><p>疑问：为什么不能这样进行赋值呢？不对好像用指针无法进行初始化？</p><p><img src="/.io//image-20221127163715081.png" alt="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221127163715081"></p>]]></content>
    
    
    <summary type="html">a freshman&#39;s practice</summary>
    
    
    
    
    <category term="assignment" scheme="http://charles-webebr.github.io/tags/assignment/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://charles-webebr.github.io/2022/11/15/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0c%E8%AF%AD%E8%A8%80/"/>
    <id>http://charles-webebr.github.io/2022/11/15/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0c%E8%AF%AD%E8%A8%80/</id>
    <published>2022-11-15T14:20:59.706Z</published>
    <updated>2023-09-26T11:52:08.181Z</updated>
    
    <content type="html"><![CDATA[<blockquote><meta name="referrer" content="no-referrer"><h1 id="从零开始学习c语言"><a href="#从零开始学习c语言" class="headerlink" title="从零开始学习c语言"></a><em><strong>从零开始学习c语言</strong></em></h1><h1 id="常用快捷键："><a href="#常用快捷键：" class="headerlink" title="常用快捷键："></a>常用快捷键：</h1><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img//image-20221117014701069.png" alt="image-20221117014701069"></p><p>除html与php外其他多少和c语言沾边</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img//image-20221117021453185.png" alt="image-20221117021453185"></p><p>一些概念：</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img//image-20221117021840466.png" alt="image-20221117021840466"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img//image-20221117021912231.png" alt="image-20221117021912231"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img//image-20221117024217615.png" alt="image-20221117024217615"></p><h1 id="容量转换"><a href="#容量转换" class="headerlink" title="容量转换"></a>容量转换</h1><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230104162014072.png" alt="image-20230104162014072"></p><h1 id="浮点数的储存形式"><a href="#浮点数的储存形式" class="headerlink" title="浮点数的储存形式"></a>浮点数的储存形式</h1><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230104175053588.png" alt="image-20230104175053588"></p><h1 id="二进制：1-10进转2进（小数有精度要求）"><a href="#二进制：1-10进转2进（小数有精度要求）" class="headerlink" title="二进制：1.  10进转2进（小数有精度要求）"></a>二进制：1.  10进转2进（小数有精度要求）</h1><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221115222016901.png" alt="image-20221115222016901"></p><p>整数自下而上，小数自下而上</p><p><strong>自己做了个二进制</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jsut a sudden spark for fun.(for int number)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span>  i=<span class="number">10000</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="type">char</span> option;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Please choose the option you want:\n&#x27;B&#x27;for decimal to binary\n&#x27;D&#x27;for binary to decimal\n&quot;</span>);</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;option);</span><br><span class="line"> <span class="keyword">if</span>(option==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line"> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> n;</span><br><span class="line"> <span class="type">long</span> <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Please input an integer\n&quot;</span>);</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line"> <span class="type">int</span> number[i];</span><br><span class="line"> <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">     number[j]=n%<span class="number">2</span>;</span><br><span class="line">     n/=<span class="number">2</span>;</span><br><span class="line">      j++;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="type">long</span> <span class="type">int</span> x=j<span class="number">-1</span>;</span><br><span class="line"> <span class="keyword">for</span>(x;x&gt;=<span class="number">0</span>;x--)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,number[x]);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">if</span>(option==<span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">     <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> m=<span class="number">0</span>;</span><br><span class="line">     <span class="type">int</span> b=<span class="number">10</span>;</span><br><span class="line">     <span class="type">int</span> number[i];</span><br><span class="line">     <span class="type">int</span> z=<span class="number">0</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Please input a binary number\n&quot;</span>);</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%llu&quot;</span>,&amp;m);</span><br><span class="line">     <span class="keyword">while</span>(m!=<span class="number">0</span>)&#123;</span><br><span class="line">     number[z]=m%b;</span><br><span class="line">     m/=b;</span><br><span class="line">     z++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">long</span> <span class="type">long</span> sum=<span class="number">0</span>;</span><br><span class="line">     <span class="type">int</span> y=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(y;y&lt;z;y++)&#123;</span><br><span class="line">         sum+=number[y]*<span class="built_in">pow</span>(<span class="number">2</span>,y);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,sum);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数据太大了hold不住了·怎么办？</p><p>（关于我睡了一觉突然灵光一现了，我们十进制转二进制用数组储存超20位的数据，那么我们二进制转十进制</p><p>不就可以用数组读入一个超20位的数据吗？）</p><p><strong>升级版（待改进）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span>  i=<span class="number">10000</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="type">char</span> option;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Please choose the option you want:\n&#x27;B&#x27;for decimal to binary\n&#x27;D&#x27;for binary to decimal\n&quot;</span>);</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;option);</span><br><span class="line"> <span class="keyword">if</span>(option==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line"> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> n;</span><br><span class="line"> <span class="type">long</span> <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Please input an integer\n&quot;</span>);</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line"> <span class="type">int</span> number[i];</span><br><span class="line"> <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">     number[j]=n%<span class="number">2</span>;</span><br><span class="line">     n/=<span class="number">2</span>;</span><br><span class="line">      j++;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="type">long</span> <span class="type">int</span> x=j<span class="number">-1</span>;</span><br><span class="line"> <span class="keyword">for</span>(x;x&gt;=<span class="number">0</span>;x--)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,number[x]);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">if</span>(option==<span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">     <span class="type">int</span> number[i];</span><br><span class="line">     <span class="type">int</span> z=<span class="number">0</span>;</span><br><span class="line">     <span class="type">int</span> ret=<span class="number">1</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Please input a binary number,then input a letter to stop\n&quot;</span>);</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">      ret=<span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>,&amp;number[z]);</span><br><span class="line">      ++z;</span><br><span class="line">      &#125;<span class="keyword">while</span>(ret==<span class="number">1</span>);</span><br><span class="line">     <span class="type">long</span> <span class="type">long</span> sum=<span class="number">0</span>;</span><br><span class="line">     <span class="type">int</span> y=z<span class="number">-2</span>;</span><br><span class="line">     <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(y,j;y&gt;=<span class="number">0</span>,j&lt;z<span class="number">-1</span>;y--,j++)&#123;</span><br><span class="line">         sum+=number[y]*<span class="built_in">pow</span>(<span class="number">2</span>,j);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,sum);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img//image-20221118232030474.png" alt="image-20221118232030474"></p><p><strong>这是学长和老师给出的解释（）明天试试</strong></p><p>[^已用字符串数组解决，代码放在answer了]: </p><p>用补码。</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img//image-20221116005548142.png" alt="image-20221116005548142"></p><h1 id="补码怎么求？"><a href="#补码怎么求？" class="headerlink" title="补码怎么求？"></a>补码怎么求？</h1><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img//image-20221117003141327.png" alt="image-20221117003141327"></p><p>八进制</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img//image-20221117004034441.png" alt="image-20221117004034441"></p><p>十六进制</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img//image-20221117004527624.png" alt="image-20221117004527624"></p><p>比武大会的一个不错的题目：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 65  <span class="comment">//增加一个字符用来放标识符，便于判断。</span></span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">myPow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> x)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> str[N]=&#123;<span class="number">0</span>&#125;,i=<span class="number">0</span>;    <span class="comment">//str初始化为空字符,下标计数i不会超过N，所以用char类型就可以，用int当然也可以。</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum=<span class="number">0</span>;  <span class="comment">//这里为什么不能用int？</span></span><br><span class="line"><span class="keyword">while</span>((str[i++]=getchar())!=<span class="string">&#x27;\n&#x27;</span>) <span class="comment">//先不考虑用户在中途输入非法字符的情况，如果需要考虑的话就需要增加判断条件</span></span><br><span class="line">   <span class="keyword">if</span>(i==N)  <span class="keyword">break</span>;<span class="comment">//做边界判断</span></span><br><span class="line">str[i<span class="number">-1</span>] = <span class="string">&#x27;\n&#x27;</span>;   <span class="comment">//  str[i-1]读到的是&#x27;\n&#x27;，或者i为N的时候，str[i-1]也超出64个字符，这时也强行赋值为&#x27;\n&#x27;，逻辑就一致。等学了字符串之后，我们会强行赋值为&#x27;\0&#x27;</span></span><br><span class="line"><span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>)  <span class="comment">//这时str[0]是最高位为符号位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;str[j]!=<span class="string">&#x27;\n&#x27;</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(str[j]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">         <span class="keyword">if</span>((i<span class="number">-2</span>)-j&gt;=<span class="number">0</span>) <span class="comment">//这个判断不要也没问题，要了是为了更好读。</span></span><br><span class="line">            sum+=myPow(<span class="number">2</span>,(i<span class="number">-2</span>)-j);<span class="comment">//有效元素的下标是i-2,因为str[i-1]==&#x27;\n&#x27;</span></span><br><span class="line">    &#125;<span class="comment">//这个大括号不能省略，否则后面那个else会匹配到这个if，我在讲选择结构时详细说明了原因。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">&#x27;1&#x27;</span>)  <span class="comment">//这时str[0]也就是符号位为1为负数的补码</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;str[j]!=<span class="string">&#x27;\n&#x27;</span>;j++)  <span class="comment">//这时str[0]上的1是符号位，从次高位开始不为1的数据为真实数据，因为负数的补码前面再多的1都不影响结果</span></span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span>(str[j]==<span class="string">&#x27;0&#x27;</span>)   <span class="comment">//补码是怎么来的？是符号位为1，其他位为对应的正数原码取反再+1得到的;补码的本质是从0减下来的，0-1得到的是-1的补码、0-2得到的是-2的补码；</span></span><br><span class="line">             <span class="keyword">if</span>((i<span class="number">-2</span>)-j&gt;=<span class="number">0</span>) <span class="comment">//这判断可以不要，不影响逻辑和结果</span></span><br><span class="line">                sum+=myPow(<span class="number">2</span>,(i<span class="number">-2</span>)-j);</span><br><span class="line">        &#125;</span><br><span class="line">     sum= -(sum+<span class="number">1</span>);  <span class="comment">//因为是原码取反后再加1得到的，这里也需要加1再取相反数。注意按位取反和取相反数是不同的计算。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>    <span class="comment">//如果字符数组得到的第一个元素就是换行符或者是0或1之外的字符，说明用户没有输入过数字或者第一个字符就输入了非法的字符</span></span><br><span class="line">  &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;No number\n&quot;</span>);<span class="comment">//用户的输入不是有效输入</span></span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">0</span>);  <span class="comment">//程序退出</span></span><br><span class="line">  &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;decimal=%lld\n&quot;</span>,sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">myPow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> powNum=<span class="number">1</span>;<span class="comment">//powNum会参与乘积的计算，先赋初值为1；如果这个变量需要做累加计算的话，就要先赋值为0.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x;i++)  <span class="comment">//如果形参接收的x为0，这个循环不执行，返回的powNum是1</span></span><br><span class="line">     powNum *= a;</span><br><span class="line">  <span class="keyword">return</span> powNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="gets-gets-s-fgets之间的区别。"><a href="#gets-gets-s-fgets之间的区别。" class="headerlink" title="gets,gets_s,fgets之间的区别。"></a><strong>gets,gets_s,fgets之间的区别。</strong></h1><h2 id="换行符的处理："><a href="#换行符的处理：" class="headerlink" title="换行符的处理："></a>换行符的处理：</h2><ol><li>gets会将最后的’\n’改成’\0’,gets_s会把最后的’\n’直接丢弃，fgets直接读取’\n’</li><li>gets_s会将未读取的数据直接清空（为了读取数据不出幺蛾子),而fgets会保留未读取的部分，gets如果数据越界了会将不属于他的数据给覆盖，有很大的安全隐患。</li><li>fgets的使用：char *fgets(char *<strong>restrict</strong> _Buf, int _MaxCount, FILE *<strong>restrict</strong> _File)</li></ol><p>粒子：</p><p>a&#x3D;20;</p><p>char[a];</p><p>fgets(a,20,stdin);（stdin从用户那里读入数据，如果这里是文件名的话那么从文件读取数据）</p><p><strong>补充：</strong></p><p>stdin与stdout：stdin是标准输入流，是标准输出流，类似于scanf与printf。（升级版plus）</p><h1 id="逗号表达式"><a href="#逗号表达式" class="headerlink" title="逗号表达式"></a>逗号表达式</h1><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230104175624280.png" alt="image-20230104175624280"></p><h1 id="普通运算"><a href="#普通运算" class="headerlink" title="普通运算"></a>普通运算</h1><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230104181322654.png" alt="image-20230104181322654"></p><p>运算符优先级：</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230104182033272.png" alt="image-20230104182033272"></p><p>如何求复杂表达式的值？</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230104182619562.png" alt="image-20230104182619562"></p><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算:"></a>位运算:</h1><p>相关运算符</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230104184148208.png" alt="image-20230104184148208"></p><p>1.（可以升级之前的一些操作，比如说判断奇偶数，按位与会更快一点）</p><p>只要有0就是0</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230104184629199-1672829191018-1.png" alt="image-20230104184629199"></p><p>2.只要有一就是一<img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230104185352538.png" alt="image-20230104185352538"></p><p>3.正常性取向（）</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230104185833513.png" alt="image-20230104185833513"></p><p>4.按位左移与按位右移在没有溢出的条件下分别对应乘了2的n次方</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230105100211093.png" alt="image-20230105100211093"></p><p>（绷不住了，寒假白兰到还有17天）</p><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>（1）结构体内存分配原则：</p><ul><li>原则一：结构体中元素按照定义顺序存放到内存中，但并不是紧密排列。从结构体存储的首地址开始 ，每一个元素存入内存中时，它都会认为内存是以自己的宽度来划分空间的，因此元素存放的位置一定会在自己大小的整数倍上开始。</li><li>原则二： 在原则一的基础上，检查计算出的存储单元是否为所有元素中最宽的元素长度的整数倍。若是，则结束；否则，将其补齐为它的整数倍。</li></ul><p>（2）定义位域时，各个成员的类型最好保持一致，比如都用char，或都用int，不要混合使用，这样才能达到节省内存空间的目的。</p><h1 id="sscanf与sprintf语法"><a href="#sscanf与sprintf语法" class="headerlink" title="sscanf与sprintf语法"></a>sscanf与sprintf语法</h1><h2 id="scsanf"><a href="#scsanf" class="headerlink" title="scsanf():"></a>scsanf():</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//昨天练习题目的参考答案：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">double</span> sum=<span class="number">0</span>,num1,num2;</span><br><span class="line">   <span class="type">char</span> a[]=<span class="string">&quot;123.45 456.78&quot;</span>;</span><br><span class="line">   <span class="type">char</span> b[<span class="number">30</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">   &#123;<span class="built_in">sscanf</span>(a,<span class="string">&quot;%lf%lf&quot;</span>,&amp;num1,&amp;num2);&#125;</span><br><span class="line">   sum=num1+num2;</span><br><span class="line">   <span class="built_in">sprintf</span>(b,<span class="string">&quot;sum=%f&quot;</span>,sum);</span><br><span class="line">   <span class="built_in">puts</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>C 库函数 <strong>int sscanf(const char *str, const char *format, …)</strong> 从字符串读取格式化输入。</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>下面是 sscanf() 函数的声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面的实例演示了 sscanf() 函数的用法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> day, year;</span><br><span class="line">   <span class="type">char</span> weekday[<span class="number">20</span>], month[<span class="number">20</span>], dtm[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">   <span class="built_in">strcpy</span>( dtm, <span class="string">&quot;Saturday March 25 1989&quot;</span> );</span><br><span class="line">   <span class="built_in">sscanf</span>( dtm, <span class="string">&quot;%s %s %d  %d&quot;</span>, weekday, month, &amp;day, &amp;year );</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%s %d, %d = %s\n&quot;</span>, month, day, year, weekday );</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">32</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sscanf</span>(<span class="string">&quot;123456abcdedf&quot;</span>, <span class="string">&quot;%31[0-9]&quot;</span>, str);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;str=%s/n&quot;</span>, str);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str=<span class="number">123456</span></span><br></pre></td></tr></table></figure><p>上面的格式中，[0-9]表示这是一个仅包含0-9这几个字符的字符串，前面使用数字31修饰词表示这个字符串缓冲区的最大长度</p><h2 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf():"></a>sprintf():</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>C 库函数 <strong>int sprintf(char *str, const char *format, …)</strong> 发送格式化输出到 <strong>str</strong> 所指向的字符串。</p><h3 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h3><p>下面是 sprintf() 函数的声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br></pre></td></tr></table></figure><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>下面的实例演示了 sprintf() 函数的用法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">   <span class="type">char</span> str[<span class="number">80</span>];</span><br><span class="line"></span><br><span class="line">   <span class="built_in">sprintf</span>(str, <span class="string">&quot;Pi 的值 = %f&quot;</span>, M_PI);</span><br><span class="line">   <span class="built_in">puts</span>(str);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="1-定义（略）"><a href="#1-定义（略）" class="headerlink" title="1.定义（略）"></a>1.定义（略）</h2><h2 id="2-指针的算数意义"><a href="#2-指针的算数意义" class="headerlink" title="2.指针的算数意义"></a>2.指针的算数意义</h2><ul><li>指针的每一次递增，它其实会指向下一个元素的存储单元。</li><li>指针的每一次递减，它都会指向前一个元素的存储单元。</li><li>指针在递增和递减时跳跃的字节数取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节。</li></ul><h2 id="3-指针数组"><a href="#3-指针数组" class="headerlink" title="3.指针数组"></a>3.指针数组</h2><p>用一个指向字符的指针数组来存储一个字符串列表，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">const</span> <span class="type">char</span> *names[] = &#123;</span><br><span class="line">                   <span class="string">&quot;Zara Ali&quot;</span>,</span><br><span class="line">                   <span class="string">&quot;Hina Ali&quot;</span>,</span><br><span class="line">                   <span class="string">&quot;Nuha Ali&quot;</span>,</span><br><span class="line">                   <span class="string">&quot;Sara Ali&quot;</span>,</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Value of names[%d] = %s\n&quot;</span>, i, names[i] );</span><br><span class="line">    <span class="comment">//names[i]前面不需要加*，因为c中字符串指针输出全部只需要开头的指针，</span></span><br><span class="line">    <span class="comment">//即数组名str，加了*只会取出第一个元素</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Value of names[0] = Zara Ali</span><br><span class="line">Value of names[1] = Hina Ali</span><br><span class="line">Value of names[2] = Nuha Ali</span><br><span class="line">Value of names[3] = Sara Ali</span><br></pre></td></tr></table></figure><h2 id="4-指向指针的指针"><a href="#4-指向指针的指针" class="headerlink" title="4.指向指针的指针"></a>4.指向指针的指针</h2><p>（二维数组中有所体现）</p><h2 id="5-从函数返回指针"><a href="#5-从函数返回指针" class="headerlink" title="5.从函数返回指针"></a>5.从函数返回指针</h2><p>static int  r[10];&#x2F;&#x2F;函数里的变量如果想返回地址需要加上static</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20230201230854265-1675264144663-1.png" alt="image-20230201230854265"></p><h2 id="6-函数指针"><a href="#6-函数指针" class="headerlink" title="6.函数指针"></a>6.函数指针</h2><p>函数指针是指向函数的指针变量。</p><p>通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。</p><p>函数指针可以像一般函数一样，用于调用函数、传递参数。</p><h4 id="函数指针变量的声明："><a href="#函数指针变量的声明：" class="headerlink" title="函数指针变量的声明："></a>函数指针变量的声明：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*fun_ptr)</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>; <span class="comment">// 声明一个指向同样参数、返回值的函数指针类型</span></span><br></pre></td></tr></table></figure><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>‘’函数指针作为某个函数的参数’‘</p><p>函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。</p><p>简单讲：回调函数是由别人的函数执行时调用你实现的函数。</p><blockquote><p>以下是来自知乎作者常溪玲的解说：</p><p>你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。</p></blockquote></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;从零开始学习c语言&quot;&gt;&lt;a href=&quot;#从零开始学习c语言&quot; class=&quot;headerlink&quot; title=&quot;从零开始学习c语言&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>answer</title>
    <link href="http://charles-webebr.github.io/2022/10/29/answer/"/>
    <id>http://charles-webebr.github.io/2022/10/29/answer/</id>
    <published>2022-10-29T00:42:02.000Z</published>
    <updated>2023-09-26T11:51:46.750Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="错题1"><a href="#错题1" class="headerlink" title="错题1*"></a><em>错题1</em>*<img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20221028_132523-1667192539473-5.png"></h1><p>假设b已经是a的因子之和，那么只要证明b的因子之和也等于a即可，如此简化了计算</p><h1 id="无题（太逆天了）"><a href="#无题（太逆天了）" class="headerlink" title="无题（太逆天了）"></a><u><em><strong>无题</strong></em></u>（太逆天了）</h1><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20221028_140506-1667192552740-7.png"></p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20221028_152146-1667192562705-9.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的理解，虽然一开始没写出来呜呜呜（从E到A）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (x = <span class="number">4</span>;x&lt;=<span class="number">10000</span>; x+=<span class="number">4</span>)</span><br><span class="line">    &#123;   <span class="type">int</span> a=x;</span><br><span class="line">        <span class="keyword">while</span> (x % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; i &lt;= <span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        </span><br><span class="line">            x = <span class="number">1.25</span> * x + <span class="number">1</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((x - <span class="number">1</span>) % <span class="number">20</span> == <span class="number">0</span> &amp;&amp; i == <span class="number">6</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Total number of fish catched=%d\n&quot;</span>, x);</span><br><span class="line">           </span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        x=a;</span><br><span class="line">        i =<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是直接从A到E的方法（自己写的！！！！！）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">626</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n=x<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (n;n&lt;=<span class="number">3200</span>; n+=<span class="number">5</span>)</span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">while</span> ((x<span class="number">-1</span>) % <span class="number">5</span> == <span class="number">0</span> &amp;&amp; i &lt;= <span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        </span><br><span class="line">            x =  (x - <span class="number">1</span>)*<span class="number">0.8</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( i == <span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Total number of fish catched=%d\n&quot;</span>, n<span class="number">-4</span>);</span><br><span class="line">           </span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        x=n+<span class="number">1</span>;</span><br><span class="line">        i =<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20221030_221648.png"></p><p>​        <em><strong><u>注意有些时候也得用上宏常量</u></strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//参考答案（我和他是同一个思路，但是我忽略了金融是很“精准”的，一般情况下不可以用double这样的近似数，不然数据最后出来会有偏差，所以我们要用到宏常量）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  RATE  0.01875</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  MONTHS 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  CAPITAL 1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  YEARS 5</span></span><br><span class="line">main()</span><br><span class="line">&#123;       </span><br><span class="line">    <span class="type">int</span>  i;</span><br><span class="line">    <span class="type">double</span> deposit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; YEARS; i++)</span><br><span class="line">    &#123;       </span><br><span class="line">        deposit = (deposit + CAPITAL) / (<span class="number">1</span> + RATE * MONTHS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;He must save %.2f at the first year.\n&quot;</span>, deposit);</span><br><span class="line">&#125;       </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你好漂亮</p><p>yalima怎么这么难搞（scanf有返回值，每成功读取到一个数加1，没读到为0，形式为a&#x3D;scanf(“”);</p><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20221030_221648.pngimage-20221104213220993.png" alt="image-20221104213220993"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x1=<span class="number">0</span>,x2=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> re=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (re!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input x1, x2:\n&quot;</span>);</span><br><span class="line">        re=<span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;x1,&amp;x2);</span><br><span class="line">        <span class="keyword">if</span>(re!=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(getchar()!=<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span>(x1*x2&lt;<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;x1=%d,x2=%d\n&quot;</span>, x1, x2);</span><br><span class="line">         re=<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        re=<span class="number">0</span>; </span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这题要分闰年和每月的天数</p><p>问题是每年的天数还不一样，还得做一个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>,Sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%4d-%2d-%2d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    <span class="type">int</span> MAX[<span class="number">12</span>]=&#123;<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line">    <span class="comment">//利用数组记录每月月数</span></span><br><span class="line">    <span class="comment">//闰年改二月的日期</span></span><br><span class="line">    <span class="keyword">if</span>(a%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;a%<span class="number">100</span>!=<span class="number">0</span>&amp;&amp;a%<span class="number">400</span>==<span class="number">0</span>)</span><br><span class="line">    MAX[<span class="number">1</span>]=<span class="number">29</span>;</span><br><span class="line">    <span class="comment">//计算？月距离一月一号过了多少天</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;b;i++)&#123;</span><br><span class="line">        sum+=MAX[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1990</span>;j&lt;a;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;a%<span class="number">100</span>!=<span class="number">0</span>&amp;&amp;a%<span class="number">400</span>==<span class="number">0</span>)</span><br><span class="line">            Sum+=<span class="number">366</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Sum+=<span class="number">365</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ret=(sum+Sum+c)%<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span>(b&lt;<span class="number">0</span>||b&gt;<span class="number">12</span>||c&lt;<span class="number">0</span>||c&gt;MAX[b<span class="number">-1</span>])&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid input.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ret==<span class="number">0</span>||ret==<span class="number">4</span>)</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;He is having a rest.&quot;</span>);</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;He is working.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="rand-的使用方法"><a href="#rand-的使用方法" class="headerlink" title="rand()的使用方法"></a><em><strong>rand()的使用方法</strong></em></h1><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/image-20221106211446271.png" alt="image-20221106211446271" style="zoom: 80%;"><p>简单点：rand()%(b-a+1)+a表示【a，b】区间</p><p>一般使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">98</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">678</span>;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    number=rand()%(b-a+<span class="number">1</span>)+a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,number);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>assert用法：</p><p>类似于if语句，但它快一点，不影响效率。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先打个头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line">assert(.....);<span class="comment">//这里有分号，而且它加不了大括号。</span></span><br><span class="line">.......</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1533703751407</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">编程验证哥德巴赫猜想：任意一个充分大的偶数，可以用两个素数之和表示。如：</span><br><span class="line">4 = 2 + 2    6 = 3 + 3。</span><br><span class="line">**输入格式要求：&quot;%d&quot; 提示信息：&quot;Input a number:\n&quot; 输入奇数时报错： &quot;Input error!\n&quot;</span><br><span class="line">**输出格式要求：输入偶数时显示&quot;%d=%d+%d\n&quot;</span><br><span class="line">程序的运行的输入输出样例1：</span><br><span class="line">屏幕先显示提示信息：</span><br><span class="line">Input a number:</span><br><span class="line">然后用户键盘输入：</span><br><span class="line">9</span><br><span class="line">最后屏幕输出：</span><br><span class="line">Input error!         </span><br><span class="line">程序的运行的输入输出样例2：</span><br><span class="line">屏幕先显示提示信息：</span><br><span class="line">Input a number:</span><br><span class="line">然后用户键盘输入：</span><br><span class="line">100</span><br><span class="line">最后屏幕输出：</span><br><span class="line">100=3+97</span><br></pre></td></tr></table></figure><p>日哦，for里面的自增变量打错了，搞起我循环没出来。。。。。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isprime</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">    <span class="type">int</span> isprime=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;<span class="built_in">sqrt</span>(a);i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a%i==<span class="number">0</span>)</span><br><span class="line">        isprime=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isprime;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input a number:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isprime(i)&amp;&amp;isprime(j)&amp;&amp;(i+j)==n)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d=%d+%d&quot;</span>,n,i,j);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="有意思的一题"><a href="#有意思的一题" class="headerlink" title="有意思的一题"></a>有意思的一题</h1><p><strong>魔术师利用一副牌中的13张黑桃，预先将它们排好后迭在一起，牌面朝下。对观众说：我不看牌，只数数就可以猜到每张牌是什么，我大声数数，你们听，不信？你们就看。魔术师将最上面的那张牌数为1，把它翻过来正好是黑桃A，将黑桃A放在桌子上，然后按顺序从上到下数手上的余牌，第二次数1、2，将第一张牌放在这迭牌的下面，将第二张牌翻过来，正好是黑桃2，也将它放在桌子上，第三次数1、2、3，将前面两张依次放在这迭牌的下面，再翻第三张牌正好是黑桃3。这样依次进行将13张牌全翻出来，准确无误。问魔术师手中的牌原始顺序是怎样安排的？</strong>（有点意思，不难但是没思路会很痛苦）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的解法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> number[<span class="number">13</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(n=<span class="number">1</span>;n&lt;=<span class="number">13</span>;n++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i;i&lt;<span class="number">13</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(number[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                ret=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count==n)&#123;</span><br><span class="line">                number[i]=n;</span><br><span class="line">                ret=<span class="number">1</span>;</span><br><span class="line">                count=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ret==<span class="number">0</span>)&#123;</span><br><span class="line">            n--;</span><br><span class="line">            i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">13</span>;j++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,number[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个大哥写的代码，我现在还看不明白。（代码武林里面的位运算，还不会，得学）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printBinary</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">        printBinary(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">printBinary</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">int</span> cnt=(<span class="keyword">sizeof</span>(num)&lt;&lt;<span class="number">3</span>)<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=cnt;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp=num&gt;&gt;i;</span><br><span class="line">        <span class="type">int</span> b=temp&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组如何定义？"><a href="#数组如何定义？" class="headerlink" title="数组如何定义？"></a>数组如何定义？</h1><p><strong>) 定义数组时给所有元素赋初值</strong>，这叫“完全初始化”。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a[5] = &#123;1, 2, 3, 4, 5&#125;;</span><br></pre></td></tr></table></figure><p><strong>2) 可以只给一部分元素赋值</strong>，这叫“不完全初始化”。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a[5] = &#123;1, 2&#125;;</span><br></pre></td></tr></table></figure><p>需要注意的是，“不完全初始化”和“完全不初始化”不一样。如果“完全不初始化”，即只定义“int a[5]；”而不初始化，那么各个元素的值就不是0了，所有元素都是垃圾值。（有些编译器会自动给你变成0）</p><p>你也不能写成“int a[5]&#x3D;{}；”。如果大括号中什么都不写，那就是极其严重的语法错误。大括号中最少要写一个数。比如“int  a[5]&#x3D;{0}；”，这时就是给数组“清零”（我的vs要放在主函数前面），此时数组中每个元素都是零。此外，如果定义的数组的长度比花括号中所提供的初值的个数少，也是语法错误，如“a[2]&#x3D;{1，2，3，4，5}；（会占据其他数据的位置）</p><p><strong>3) 如果定义数组时就给数组中所有元素赋初值，那么就可以不指定数组的长度，因为此时元素的个数已经确定了。</strong>编程时我们经常都会使用这种写法，因为方便，既不会出问题，也不用自己计算有几个元素，系统会自动分配空间。例如：</p><p>（很多的时候你怎么办嘛）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a[5] = &#123;1, 2, 3, 4, 5&#125;;</span><br></pre></td></tr></table></figure><p>可以写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a[] = &#123;1, 2, 3, 4, 5&#125;;</span><br></pre></td></tr></table></figure><p>第二种写法的花括号中有 5 个数，所以系统会自动定义数组 a 的长度为 5。但是要注意，只有在定义数组时就初始化才可以这样写。如果定义数组时不初始化，那么省略数组长度就是语法错误。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a[];</span><br></pre></td></tr></table></figure><p>那么编译时就会提示错误，编译器会提示你没有指定数组的长度。</p><p>**4.**输入数字时必须用 for 循环进行输入。而输入字符串时无须用循环，直接用 scanf 就可以了。(确实真的爽)</p><p><a href="//jsut%20a%20sudden%20spark%20for%20fun.(for%20int%20number)%0A#include%20%3Cstdio.h%3E%0A#include%20%3Cmath.h%3E%0Aint%20%20i=10000;%0Aint%20main()%7B%0A%20%20%20%20char%20option;%0A%20%20%20%20printf(%22Please%20choose%20the%20option%20you%20want:%5Cn'B'for%20decimal%20to%20binary(10-%3E2)%5Cn'D'for%20binary%20to%20decimal(2-%3E10)%5Cn%22"></a></p><p>理解了一点字符数组和字符串数组再改进的二进制转换器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jsut a sudden spark for fun.(for int number)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span>  i=<span class="number">10000</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> option;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please choose the option you want:\n&#x27;B&#x27;for decimal to binary(10-&gt;2)\n&#x27;D&#x27;for binary to decimal(2-&gt;10)\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;option);</span><br><span class="line">    <span class="keyword">if</span>(option==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please input an integer\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> number[i];</span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">       </span><br><span class="line">        number[j]=n%<span class="number">2</span>;</span><br><span class="line">        n/=<span class="number">2</span>;</span><br><span class="line">         j++;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> x=j<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(x;x&gt;=<span class="number">0</span>;x--)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,number[x]);</span><br><span class="line"> &#125;<span class="comment">//算输入了多少位二进制数（以后求位数有新选择了）</span></span><br><span class="line">    <span class="type">char</span>  number[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span> <span class="title function_">len</span><span class="params">(<span class="type">char</span> number [])</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(number[len])</span><br><span class="line">        len++;</span><br><span class="line">    <span class="keyword">return</span> len;    </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(option==<span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> sum;</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;number);</span><br><span class="line">     count=len(number);</span><br><span class="line">     <span class="keyword">for</span>(i=count<span class="number">-1</span>,j=<span class="number">0</span>;i&gt;=<span class="number">0</span> ;i--,j++)</span><br><span class="line">     &#123;</span><br><span class="line">     sum+=(number[i]<span class="number">-48</span>)*<span class="built_in">pow</span>(<span class="number">2</span>,j);   </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%ld&quot;</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="字符类数组的自我理解："><a href="#字符类数组的自我理解：" class="headerlink" title="字符类数组的自我理解："></a><strong>字符类数组的自我理解：</strong></h1><p><strong>1.</strong>      char[20]可以理解成char[20] [1]这个东西</p><ol start="2"><li>然后字符串可以看成char[a] [b]，一共有a个子块，每个子块的位数为b，例如</li></ol><p>   ”广域网“，”经纬度“，”互换了“。。。。。</p><p>   3.如果a&#x3D;1；那么我们可以写成char[20]这种的字符串数组（是不是和第一点很像？其实他们就差了个%c与%s</p><p>   4.这种数组好像可以做函数参数，感觉挺方便的wwww，有空学习一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">鲁智深吃馒头</span><br><span class="line">据说，鲁智深一天中午匆匆来到开封府大相国寺，想蹭顿饭吃，当时大相国寺有99个和尚，只做了99个馒头，智清长老不愿得罪鲁智深，便把他安排在一个特定位置，之后对所有人说，从我开始报数（围成一圈），第5个人可以吃到馒头（并退下），按照这个公平的方法，所有和尚都吃到了馒头，唯独鲁智深没有吃上。请问他在哪个位置？</span><br><span class="line">要求编程计算该位置并输出。</span><br><span class="line">输入格式:无</span><br><span class="line">输出格式：</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> a[<span class="number">100</span>]=&#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span>(i,k;k&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]==<span class="number">0</span>)</span><br><span class="line">        j++;</span><br><span class="line">    <span class="keyword">if</span>((j%<span class="number">5</span>==<span class="number">0</span>)&amp;&amp;a[i]==<span class="number">0</span>)&#123;</span><br><span class="line">       a[i]=<span class="number">1</span>;</span><br><span class="line">       k++;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">if</span>(i==<span class="number">100</span>)  </span><br><span class="line">    i=<span class="number">-1</span>;</span><br><span class="line">   <span class="keyword">if</span>(k==<span class="number">99</span>)</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">0</span>;m&lt;<span class="number">100</span>;m++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[m]==<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,m+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（感觉不是特别难，但我就是弄了很久）</p><h1 id="指针困惑"><a href="#指针困惑" class="headerlink" title="指针困惑"></a>指针困惑</h1><p><img src="https://gitee.com/Charles-Webber/blog-image1/raw/master/img/-bdcd8f8e098f9b1[10].png" alt="-bdcd8f8e098f9b1[10]"></p><p>困惑一：(int (*)[3])a其实就是将a这个4×3的二维数组转成了3×4的，名字变成了b</p><p>困惑二：为什么只有三列却出现了[3]呢？其实a[1]+1表示a[1] [1],那么这个三是可以参与计算的，化简得(b[2]-2)[3]&#x3D;b[2]-2+3&#x3D;b[2] [1],最后再加加得到10</p>]]></content>
    
    
    <summary type="html">a freshman&#39;s practice</summary>
    
    
    
    
    <category term="answer" scheme="http://charles-webebr.github.io/tags/answer/"/>
    
  </entry>
  
</feed>
